## [1, 2, 3 떨어트리기](https://school.programmers.co.kr/learn/courses/30/lessons/150365)

---

4단계 문제로 로직도 복잡하고 구현해야 할 코드 줄 수도 많아 굉장히 고생한 문제이다.

중요한 조건은 숫자는 가능한 한 적어야 하고, 가능한 한 작은 숫자가 앞에 나와야 한다. 첫 번째 조건의 만족을 위해서는 루트부터 리프까지의 여러 경로 중 가장 critical한 경로를 구해야 했다. 즉 여러 경로 중 가장 많은 공이 입력되야 할 경로이다. (같은 개수가 있다면 그 중 가장 우측 경로이다.) 그 경로에 입력되는 공의 개수를 최소로 한다면 나머지 경로의 공의 개수는 그 경로에 맞추면 된다. 이 경우, 해당 경로보다 왼쪽에 있다면 같은 개수의 공의 입력하고, 오른쪽에 있다면 공의 개수 -1 개를 입력한다. 만약 다른 경로가 이 critical path의 공의 개수 조건에 따라 입력되야 할 공의 개수를 만족하지 못한다면, 해당 트리는 불가능한 트리이다.

때문에 먼저 트리를 연결한 후, 트리를 순회하며 각 경로마다 최소로 필요한 공의 개수 minCnt를 저장했다. 리프노드의 경우 해당 value에 3, 2, 1을 차례로 채워넣은 숫자이고, 이후 위로 올라간다면 자식노드의 minCnt들 중 가장 큰 값을 기준으로 아래와 같다.

    (minCnt * 해당 자식노드 포함 좌측 자식노드 개수) + ((minCnt -1) * 우측 자식노드 개수)

이후엔 저장된 minCnt값에 따라 critical 경로를 선택하여 트리를 쭉 내려간다. 그리고 리프 노드부터 실제 숫자 조합 order를 만들어낸다. critical 경로의 리프노드의 order는 간단히 해당 value에 따라 최적의 조합을 만들면 된다. 이 로직은 `Node.findMainPath` 로 구현되었다.

이후 위로 올라가며 critical 경로의 형제 노드들에서도 order를 만들어내 앞에서부터 한 개의 값씩 조합한다. 이 때 조건과 같이 형제 노드가 critical node보다 왼쪽에 있다면 같은 개수의 order를 만들어야 하고, 우측에 있다면 개수-1 개의 order를 만들어내야 한다. 이는 공이 숫자 순서대로 좌측에서부터 순서대로 들어가야 하기 때문이다. 이러한 과정에서 어떤 형제 노드가 critical의 개수 조건을 만족하지 못한다면 해당 트리는 불가능한 트리이다. 이 로직은 `Node.getOrders`로 구현되었다.

이렇게 critical path를 쭉 내려갔다가 올라오며 order를 조합해가면 결과적으로 critical path의 최소 개수 조건에 맞추어 생성된 다른 형제 노드들과의 order와 조합된 최종 결과가 나타난다. 전체 로직은 일종의 dfs방식을 따라 재귀로 구현하여 만들었다.

코드 줄 수가 매우 길어지다 보니 시간도 오래 걸렸고 잔 실수도 많았다. 다른 사람의 풀이를 보니 실제 경로가 열고 닫히는것을 구현해 숫자를 하나씩 넣어보는 식으로 구현한 사람도 있었는데, 그 풀이도 참고하는것이 좋겠다.
