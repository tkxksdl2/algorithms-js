## [2023 현대모비스 알고리즘 경진대회 예선 집합과 쿼리](https://school.programmers.co.kr/learn/courses/30/lessons/214291)

---

이 문제를 풀기 위해선 쿼리가 집합을 만드는 과정을 제대로 이해해야만 한다. 문제에서 요구하는 동작은 다음과 같다.

1. 특정 숫자가 포함된 집합의 모든 수를 가져와 다른 집합에 push 한다.

2. 특정 집합에 두 숫자가 push 된 순서를 기억하고, 그 앞뒤를 자를 수 있어야 한다.

3. 특정 숫자 두 개가 같은 집합에 있는지 파악한다.

척 보기만 해도 각 동작을 완전탐색으로 실행하면 시간초과가 날게 뻔하다. 본문 최대 n과 쿼리의 수는 500,000으로 매우 크기 때문에 이와 같은 동작을 효과적으로 수행하는 것이 관건이다.

---

일단 2번 조건을 보면 링크드 리스트가 생각난다. 값의 추가와 삭제를 O(1)로 동작 가능하고, 특정 위치에서 편리하게 리스트를 잘라낼 수 있다.
1번 조건의 경우도 링크드 리스트를 이용해 마지막 노드를 기억하면 쉽게 집합을 추가할 수 있을 것 같다.

그런데 문제는 2번 쿼리의 순서 조건과 3번 쿼리의 같은 집합에 속하는지를 확인하는 조건이다. 노드 하나가 push된 쿼리의 순서와 스스로 어떤 집합에 속하는지를 기억하고 있다고 해도 한번에 추가되거나 옮겨지는 집합의 크기가 커지면 이 값들을 모두 갱신하기가 곤란해진다.

이를 해결하기 위해선 쿼리의 과정을 자세히 뜯어봐야 한다. 쿼리가 만들어내는 집합을 push 순서에 따라서 계층형으로 구성해보면 다음과 같다.

    [0], [1], [2], [3], [4]

    쿼리 [1,0,1], [1,2,3] 실행

    [0], [2], [4]
     |    |
    [1]  [3]

    쿼리 [1,0,3] 실행

     [2], [4]
      |
     [3]
      |
    [0,1]

    쿼리 [2,3,1] 실행

    [2], [3,0,1], [4]

쿼리가 실행됨에 따라서 여러 숫자들이 쿼리 한번에 동시에 움직이는것을 확인할 수 있다.

이 문제에서 집합을 이루는 숫자는 분리될 수 있다. 그런데 집합을 분리하는 쿼리는 2번쿼리 뿐이고 이는 집합에 push 된 순서를 기준으로 분리하기 때문에, 만약 어떤 숫자들이 같은 쿼리에서 한번에 push되거나 다른 집합에서 떨어져 나와 새 집합을 이뤘다면 이 숫자들은 이후 쿼리에서 절대로 분리될 수 없다.

이러한 경우은 1번 쿼리에서 y가 포함된 집합에서 발생하고, 또 2번 쿼리로 인해 떨어져 나오는 집합에서 발생한다. 이 숫자들은 앞으로도 분리되지 않고 마치 하나의 숫자처럼 움직이기 때문에 개별 수를 고려할 필요가 없고 대표값 하나만을 선정해 하나의 숫자로 생각할 수 있다.

따라서 모든 쿼리에서 추가되거나 분리되는 숫자의 집합은 단 하나의 노드의 추가와 분리로 압축되며, 여러 노드의 값을 반복해서 갱신할 필요 없이 한 번의 갱신만을 요구하므로 시간 제한사항을 충분히 충족할 수 있다.

---

먼저 모든 숫자를 노드로 만드는 것 부터 시작한다. 노드는 링크드 리스트의 원소이고, 스스로의 숫자 n과 자신의 부모와 자식 노드인 head, child, 그리고 대표값 노드를 나타내는 label을 가지고 있다. label은 초기에 자기 자신이다.

```javascript
class Node {
  constructor(n) {
    this.n = n;
    this.label = this;
    this.listIdx;
    this.queryCnt = 0;
    this.head;
    this.child;
  }
```

listIdx는 이 노드가 몇번 list의 원소인지, queryCnt는 이 값이 추가되었을 경우 몇 번째의 쿼리로 추가되었는지를 나타낸다.

그리고 해당 노드의 대표값 노드를 찾는 getLabel() 메서드를 정의한다. 이 때 label은 계층적으로 참조되어 2단계 이상을 뛰게 될 수도 있다. 이러한 경우는 손해이므로 각 단계의 label을 최종 label값으로 갱신하는 동작도 한다.

```javascript
  getLabel() {
    let cur = this;
    const shouldUpdate = [];
    while (cur.label.n !== cur.n) {
      shouldUpdate.push(cur);
      cur = cur.label;
    }
    for (const node of shouldUpdate) node.label = cur;
    return cur;
  }
```

그리고 이제부터 query의 모든 x,y 노드는 x,y 노드의 getLabel() 값으로 대체한다. 따라서 어떤 숫자가 입력되던 그 숫자가 다른 숫자와 분리되지 않는 그룹을 가진다면 그 대표값으로 변경된다.

그리고 반복의 외부엔 증가하는 값인 queryCnt와 listCnt, 특정 번호로 생성된 list의 마지막 노드를 저장하는 tails 객체가 존재한다. LinkedList를 구현해서 tail node를 저장할수도 있지만 이 문제에서 tail node 외 다른 값은 필요하지 않기 때문에 이것만으로도 충분하다.

이후로는 쿼리를 하나씩 수행한다. 이 과정에서 새 list가 만들어진다면 listCnt 값이 증가하며 노드의 listIdx에 저장되고, 기존 집합에 push되면 queryCnt가 증가하며 노드의 queryCnt값에 저장된다. 이 값들은 2,3번 쿼리의 값 비교에 사용된다.

어떤 집합이 한번에 push되거나 집합에서 분리되어 하나의 분리되지 않는 그룹을 형성한다면 makeGroup()을 실행해 그 집합들의 모든 연결을 끊고 대표값을 적용해준다.

```javascript
  makeGroup() { //unChain()은 head,child,listIdx를 초기화한다.
    let head = this.head;
    let child = this.child;
    this.unChain();
    while (head || child) {
      if (head) {
        head.label = this;
        const nxt = head.head;
        head.unChain();
        head = nxt;
      }
      if (child) {
        child.label = this;
        const nxt = child.child;
        child.unChain();
        child = nxt;
      }
    }
  }
```

이렇게 쿼리를 통해 대표값으로 집합을 압축하고, push되거나 새 집합이 생길 때 마다 listIdx가 갱신되기 때문에 최종적으로 3번 쿼리에서 x,y 대표값의 listIdx를 비교하는 것 만으로 두 숫자가 같은 집합에 존재하는지 확인할 수 있다.

예외적으로 아직 한번도 집합을 형성하지 않은 경우엔 listIdx가 존재하지 않는데, 테스트 케이스 중 [3,2,2]와 같이 같은 숫자를 비교하는 케이스가 존재하는것 같다. 이 때문에 몇몇 케이스를 불통했는데 해당 부분을 예외처리해주니 문제없이 통과했다.
