## [징검다리](https://school.programmers.co.kr/learn/courses/30/lessons/43236)

---

## 개요

바위 사이의 거리란 각 바위가 위치한 지점부터 가장 가까운 다른바위 혹은 다리의 끝 지점까지의 거리를 말한다. 때문에 이러한 거리를 측정하기 위해서는 각 바위의 위치와 다리의 시작, 끝 지점을 고려해야만 한다.

현재 rocks는 다리의 시작 지점을 기준으로한 위치이다. 즉 각각의 바위 사이의 거리는 두 바위의 위치 차이이며, 어떤 바위가 제거된다는 것은 그 바위를 무시하고 다음 바위와의 거리비교를 하겠다는 의미가 된다.

구해야하는 것은 이러한 바위 사이의 거리 중 최소값이며, 여러 경우의 수 중 이러한 최소값이 최대 몇 까지 나타날 수 있는지를 찾는 것이다.

## 시행착오

처음에는 이 문제를 단순 최적화로 풀 수 있을 거라고 생각했다. 각 바위 사이의 거리 중 최소 거리를 나타내는 바위를 우선적으로 제거해야 한다는 것은 명확하므로, 힙큐와 같은 방법을 사용해 작은 거리를 나타내는 바위를 n번 차례로 지우면 될 것이라고 생각했다.

그러나 문제가 된 부분은 특정 바위를 삭제하는 것이 다음 단계에 영향을 끼치고, 이것을 갱신하는것에 너무 많은 비용이 든다는 것이었다. 특정 바위를 삭제하면 이전 바위와 삭제한 바위의 다음 바위의 거리에 영향을 끼치므로 기존에 만든 최소힙에 영향을 줄 것이다. 때문에 이를 갱신하려면 연결 리스트와 같이 선형적인 구조를 사용해야 하는데, 이를 힙큐와 함께 사용하는것은 너무나도 복잡하고 비합리적이었다.

## Parametric Search

이를 해결하기 위해 이 문제를 결정 문제로 변환하는 Parametric Search를 사용했다. 이는 데이터의 크기가 매우 크고, 특정 값에서의 조건 만족여부가 어느 임계값을 기준으로 가능/불가능의 일종의 정렬된 상태로 나타나 이분탐색을 사용할 수 있기 때문에 가능했다.

여기서 특정 값이란 당연히 문제에서 요구하는 바위 사이의 거리 중 최소값이고, 조건이란 현재 주어진 n으로 모든 바위 사이의 거리를 현재 검색하는 값보다 크게 만들 수 있느냐를 말한다. 때문에 이분탐색은 이 최소값을 기준으로 탐색한다. 최소값이 i 일 때, n개의 바위만 제거하고도 모든 바위사이의 거리가 i보다 큰 가를 확인하면 된다.

이 문제에서 최소값 i에는 가능한 최대값이 존재하므로, 그 값보다 i가 커지면 모두 통과하지 못하고, 그 값보다 i가 작아지면 모두 통과할 것이다. 결과적으로 최종 답은 그 임계값이 되는 i값이다.

추가로 이 문제에서는 최소값 i의 탐색 범위에 최대값을 찾을 수 있다. 예를 들어 바위가 4개이고 바위를 2개까지 삭제할 수 있다고 할 때, 최소 바위는 2개이며 그로인한 구간은 3개가 생긴다. 따라서 전체길이가 30이라면 바위가 최대한 균등하게 존재한다고 할 때 최소값의 구간의 길이는 10을 넘을수가 없다. 따라서 이분탐색의 구간은 `0 ~ 총거리/ (바위개수-지울개수 + 1)` 만큼만 수행하면 된다. (코드에서는 바위개수에 다리의 끝부분이 추가되기 때문에 +1 을 하지 않았다.)

이렇게 이분탐색을 해가며 최소값 i에서의 검사를 한다. i값이 정해졌을 때 검사는 매우 간단하다. 기준이 될 지점에서 (처음에는 다리의 시작지점으로 0이다.) 다음 바위를 확인해 위치의 차이로 거리를 확인한다. 선형적으로 탐색하므로 그 거리가 i보다 작을 경우엔 다음 바위를 지우는 선택지밖에 없다. 바위를 지웠을 경우 자연스레 거리 검사는 그 다음 바위를 찾는다. 기준 지점과 다음 바위 사이의 거리가 i보다 클 경우, 기준 지점을 다음 바위로 옮기고, 그 지점과 그 다음바위와의 검사를 계속한다.

이렇게 탐색을 계속하다가 더이상 n값이 부족해서 바위를 삭제할 수 없는데 기준값 i보다 작은 거리 지점이 존재할 경우, 해당 i와 그 i보다 큰 값은 모두 통과할 수 없으므로, 구간의 최대값을 i-1로 조정한다.

반대로 모튼 탐색을 통과했을 경우, i값과 그 i값보다 작은 값은 모두 통과하므로, 구간의 최소값을 i로 조정한다.

이러한 과정을 반복하면 결국 탐색은 통과와 불통의 임계점에 도달할 것이고, 그 임계점의 값이 i의 값 중 최대이므로 문제를 해결할 수 있다. 이 경우엔 이 값은 maxDist에 저장된다(mid값이 +1되므로 minDist는 이 값보다 +1 될 가능성이 있다). 바위의 탐색에 n, 이분탐색에 logn이 소요되므로, 총 복잡도는 O(NlogN)이다.
