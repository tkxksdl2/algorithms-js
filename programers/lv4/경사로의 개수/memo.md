## [2023 현대모비스 알고리즘 경진대회 예선 경사로의 개수](https://school.programmers.co.kr/learn/courses/30/lessons/214290)

---

dp와 행렬 연산이 조합된 문제. 문제는 크게 두 부분으로 나눌 수 있다.

1. 각 위치에서 시작하여 한 사이클을 도는 경우의 수를 구한다.

2. 사이클을 k번 반복할 때의 경우의 수를 구한다.

---

1번은 dp를 이용하여 구할 수 있다. 각 위치에서 시작하여 상하좌우로 이동해가며 현재 단계의 기울기와 알맞은 경로에만 현재 단계의 경우의 수를 더해준다.

예를들어 grid가 2x2 행렬일 때, 초기 단계에는 모든 위치에서 경로를 시작할 수 있으므로 dp 행렬은 이러한 모양일 것이다.

    1 1
    1 1

이후 각 기울기와 grid 행렬을 참조하여 몇 단계를 거치고 나면 행렬은 예를 들어 다음과 같은 모양새로 바뀔 것이다. 아래 예시는 그저 모양을 나타낸 것 뿐이므로 값에는 의미가 없다.

    4 4
    2 0

이 행렬의 의미는 **[모든 위치에서 시작 가능한]** 상태에서 1번의 사이클을 돈 후의 각 위치의 경우의 수 행렬이다. 이 행렬은 결과이면서, 행렬의 모든 값이 1(혹은 1의배수) 일 때의 mapper이기도 하다. 만약 사이클이 존재하지 않는다면 이 방법만으로도 정답을 구할 수 있을 것이다.

---

문제는 2번인데, 만약 k가 작다면 위 방법을 k번 만큼 반복하여 답을 구할 수 있다. 하지만 이 문제에서 k는 최대 10^9 이므로 당연히 시간초과가 발생하고 만다.

따라서 답을 구하기 위해선 k를 적절하게 건너뛰어야 한다는 것을 알 수 있다. 1번에서 1사이클의 mapper를 이미 구했으므로, 해당 결과값을 반복해 2사이클의 mapper를 구할 수 있고, 다시 4 사이클, 8, ..., 2^i의 mapper를 구할 수 있다.

하지만 그러기에 앞서, 현재 1번에서 구했던 결과값은 **[모든 위치에서 시작 가능한]** 상태에서, 즉 초기상태에서 시작한 결과값이다. 만약 2 사이클의 결과값을 구하고자 한다면, 1사이클 결과값에 다시 1사이클 mapper를 적용해야 한다.

그러나 처음 1사이클 결과값을 구할 때는 실제로 grid를 참조했기 때문에 dp행렬 전체를 일괄적으로 관리해도 문제가 없었지만, 지금부터는 현재 상태와 특정 사이클의 mapper만으로 현재상태 + 사이클 수 이후의의 결과를 알아내야만 한다. 이 때 모든 값이 1로 동일했던 초기 상태와 달리, 중간 상태는 각 행렬의 값이 모두 다르며 0도 포함되어 있을 수 있다. 이러한 값들은 결과 행렬에 서로 판이하게 다른 영향을 끼칠 것이므로, 행렬 각각의 위치가 결과 행렬에 구체적으로 어떻게 영향을 끼치는지를 알아야만 한다.

따라서 위에서 구했던 1번 dp 행렬만으로는 해당 동작이 불가능하고 좀 더 분해해야 한다. 이를 위해 dp행렬을 구할 때 행렬의 모든 위치에 각각 mapper를 만들어 dp를 진행한다. 앞선 예시와 같은 2x2 행렬의 경우 아래와 같은 초기단계를 설정하면 된다.

    (0,0)   (0,1)   (1,0)   (0,1) - (x, y)
     1 0     0 1     0 0     0 0
     0 0     0 0     1 0     0 1

이 네 행렬로 dp를 진행하면 2^0=1 사이클의 mapper가 총 네개가 생길 것이다. 이는 각각 y,x 위치의 값이 1사이클 후에 전체 행렬에 어떻게 영향을 끼치는지를 나타낸다.

이를 mappers라는 3차원 행렬에 저장한다. mappers[y][x][i]의 값은 y,x위치의 값이 2^i번 사이클이 지난 뒤에 결과 행렬에 어떤 영향을 끼치는지를 알려주는 mapper이다.

이후부터는 2^i <= k 인동안 각 위치의 i-1번째 mapper를 이용해 i번째 mapper를 만들어 저장한다. mapper[y][x][0]에는 1번에서 만들었던 2^0=1사이클 mapper가 저장되어 있다.
이 값은 mapper이기도 하면서 (0,0) 초기행렬이 1사이클 돈 뒤의 결과값이기도 하다. 이 결과값에 다시 mapper[y][x][0]의 mapper들을 적용하면 mapper[y][x][1] 즉 2사이클 mapper를 만들 수 있다.
이것을 k보다 작으면서 최대한 큰 2^i 사이클 mapper를 만들 때 까지 반복한다.

모든 mapper가 만들어졌다면 k를 모두 소진할 동안 초기 행렬부터 시작하여 가능한 가장 큰 mapper를 적용하면 된다.
K가 200이라면 초기행렬에 다음과 같은 mapper가 적용될 것이다.

    1 1
    1 1   cycle - 128 > 64 > 8

위와 같이 200의 사이클을 전부 돌지 않고 3번의 매핑만으로 문제를 해결할 수 있다. 이때 매핑의 횟수는 k를 이진수로 나타냈을 때 1의 개수와 같다. 200 = 11001000

---

### 경고!

자바스크립트의 경우 BigInt를 사용하여야만 한다. 일반적으로 dp문제의 경우 div값을 중간중간 나누어 주기 때문에 이러한 것을 잘 고려하지 않지만 이 문제는
중간에 경우의 수를 곱해야 하는 부분이 있고, 이 곱셈이 최대 10^9 \* 10^9 로 꽤나 큰 값을 사용하므로 오버플로우가 발생해 손실이 일어날 수 있다.

예를 들어 279632277 \* 147483634 = 41241184395654618 이지만 이를 javascript에서 찍어보면 다른 결과가 나온다.

```javascript
console.log(279632277 * 147483634);
// 41241184395654616
```

결과값에 무려 2의 손실이 일어났다. 이러한 값의 차이는 dp를 수행하면서 눈덩이처럼 불어나므로 전혀 다른 결과를 낼 수 있다.
가능한 과정 중 BigInt를 사용해 값의 손실을 방지해야만 올바른 답을 구할 수 있다.
