## [쌍둥이 빌딩 숲](https://school.programmers.co.kr/learn/courses/30/lessons/140105)

---

## 첫 시도

빌딩의 수가 n, 보이는 빌딩의 수가 c라고 했을 때, n = c 일 때는 완전히 정렬되어 있을 경우이며, 경우의 수는 하나 뿐이다. 즉 n=3, c=3 일 때 `112233`의 경우의 수만 가진다.

이 때, c -= 1 이 된다는 의미는, 보이는 빌딩의 수가 하나 줄어드는 것이므로, 가장 큰 빌딩을 제외한 빌딩 쌍 중 하나의 빌딩 쌍을 뒤쪽으로 숨긴다는 것을 의미한다. 즉 `11` 혹은 `22` 빌딩 쌍을 뒤쪽으로 이동시키는 것이다. 여기서 빌딩 쌍이 이동할 수 있는 경우의 수는 아래와 같다.

    (11)2a2b3c4c  - a, b, c, d, 의 네 가지
    11(22)3a3b    - a, b 의 두 가지

즉 경우의 수는 빌딩의 크기가 i라고 했을 때 (n-i) \* 2 이다. 그리고 n-c가 2 이상이 되었을 때 (빌딩을 두 개 이상 숨겨야 할 때) 크기가 작은 빌딩부터 순서대로 숨기고, 자동으로 정렬된다고 가정하면, 숨기는 빌딩들의 각 경우의 수를 곱한 것이 총 경우의 수가 된다. 이는 어떤 빌딩쌍을 한 빌딩 쌍 뒤 혹은 사이로 숨겼을 때, 그 자체만으로 정렬된 하나의 빌딩 쌍 처럼 취급할 수 있기 때문이다.

    위의 경우에서 11을 먼저 숨겼을 경우
    (2112)33  - 3(2112)3
              - 33(2112)
    (2211)33  - 3(2211)3
              - 33(2211)
    (22)3113  - 3(2112)3 < 작은 빌딩부터 숨겼기때문에 22가 해당 위치에 가기 위해 자동 정렬된다.
              - 3113(22)
    (22)3311  - 3(22)311
              - 3311(22)

따라서 n, c 일 때 경우의 수는 n-c 개의 빌딩을 뽑아서, 각 빌딩의 크기 i일 때 n-i \* 2 를 모두 곱한 것과 같다. 그런데 문제는 빌딩을 뽑는 경우의 수에서 나타난다. 문제에서 빌딩의 최대 개수는 100 이므로, 조합의 가장 큰 경우의 수 100C50의 경우 너무나도 큰 숫자가 나와서 사실상 계산을 할 수가 없다.

이는 각 경우를 독립적으로 계산하려 했기 때문에 나타난 문제이다. 문제 설명에서도 답이 매우 큰 숫자가 나올 수 있다고 명시되어 있으므로, 이러한 방법이 아니라 이전 단계의 값을 이용해 다음 단계를 도출해내는 dp 방식이 더 알맞다고 결론지었다.

---

## dp

문제를 보는 방식을 약간 바꾸어서, n과 c를 차례 차례 늘려간다고 생각해보면, n,c 일 때의 경우의 수를 나타내는 길이 (n,c) dp맵을 만들 수 있다. 이 dp맵을 다음과 같은 기본 값을 가지고 있다.

- 기본적으로 dp(0,0) 은 1이다. 아무 빌딩도 없는 상태이다.
- dp(0,c) c>0 은 0이다. 빌딩이 없는데 빌딩이 보일 수는 없다.
- dp(n,c) c>n 은 0이다. 존재하는 빌딩보다 많은 빌딩이 보일 수는 없다.

이 때 n=3, c=3 인 상태에서 가장 작은 빌딩 쌍을 하나 추가해 n=4 가 된다고 생각해본다. 이 때 빌딩의 값은 크기를 비교하기 위한 상대적인 크기이기 때문에 223344 에 11을 추가한다고 보아도 무방하다.

    (11) - a2b2c3d3e4f4g

이 때 a위치에 빌딩 쌍이 추가되는 경우엔 c값이 하나 증가한다. 하지만 나머지 bcdefg의 경우에는 11이 숨겨지기 때문에 c값이 변화하지 않는다. 따라서 n과 c값이 증가하는 경우는 1개, n값만 증가하는 경우는 (n-1)\*2 => (4-1)\*2=6 개 이다.

또 해당 경우의 수 들은 이전 단계인 dp(3,3) 만큼 존재하므로 (가장 작은 빌딩을 추가하므로 어떻게 배치되어 있어도 모든 자리에 들어갈 수 있다.) 서로 곱해지며 여기서 dp(3,3)은 1이다.

따라서 dp(3,3)의 값은 dp맵의 다음과 같이 다음 단계에 더해진다.

    dp(3,3) => dp(4,4) += cp(3,3)
               dp(4,3) += cp(3,3) * (4-1) * 2

이를 일반화하면 dp(n,c)의 점화식은 아래와 같다.

    dp(n,c) = dp(n-1,c-1) + dp(n-1,c) * (n-1) * 2
    (n>0, c>0)

이를 기반으로 dp(1,1)부터 목표 지점까지 dp맵을 만들어 나가면 문제없이 정답을 구할 수 있다.
