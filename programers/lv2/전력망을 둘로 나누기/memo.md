## [코딩테스트 연습 전력망을 둘로 나누기](https://school.programmers.co.kr/learn/courses/30/lessons/86971)

---

내가 사용한 풀이는 간단하다. 먼저 getCnt라는 BFS를 통해 특정 정점부터 연결된 모든 정점의 개수를 구하는 함수를 만든다. 이 함수에는 deadPoint라는 인수가 존재해서, 끊어야 할 경로인 경우에는 값이 추가되지 않는다.

각 간선이 끊어진다면, 전체 하나의 트리는 간선 [a, b]에서 끊어진다면 a를 포함하는 트리와 b를 포함하는 트리 두 가지로 나뉜다. 때문에 a,b지점에서 daedPoint를 간선[a, b]로 설정하고 chackCnt 함수를 통해 두 트리의 정점 개수를 구하면 된다.

하지만 굳이 bfs를 반복해서 돌지 않고도 답을 구할 수 있는 다른 풀이가 있기에 기록한다. 그 풀이에서는 특정 정점에서의 자식 노드의 개수 수를 기록해서 문제를 풀이했다.

이 트리에는 특별히 루트 노드라는게 없지만, 노드1이 루트노드라고 한다면, 간선 [a, b]가 절단될 경우 a와 b 중 depth가 더 큰 쪽을 루트 노드로 하는 서브트리가 하나 생긴다. 루트 노드가 b 라면, b의 자식노드 개수를 구하고 전체 노드개수 n에서 해당 숫자를 빼 분리된 두 개의 자식노드 수를 구할 수 있다.

자식노드의 개수를 누적시키는 것도 복잡한 과정 없이 각 노드는 자신의 부모 노드 번호와 자식의 수를 저장해두고, depth가 큰 순서대로 자신의 부모노드의 자식노드 수 값에 자신의 자식노드 수 값을 더하면 된다. 여기서 자식노드의 개수는 자기 자신을 포함한 값이다.

이 때 루트노드는 1이지만 이후로 부터는 숫자가 더 큰 노드가 더 작은 노드의 부모가 될 수도 있다. 때문에 각 노드 사이의 depth 관계와 구해야 정확히 부모 노드가 누구인지를 구해야 한다. 따라서 bfs를 단 한번 수행해 각 노드의 부모 노드와 depthOrder를 기억한다. bfs는 그 수행 자체만으로 depth 순서를 보장하기 때문에 호출되는 노드 번호를 순서대로 저장하기만 해도 된다.

이제 이 depthOrder의 역순 즉 depth가 높은 순서대로 자신의 자식노드 수를 부모의 자식노드 수에 더한다. 동시에 이 노드의 자식노드와 노드 1의 자식노드의 수의 차를 구해서 answer와 비교한다. 이 때 노드 1은 자식노드 수가 항상 n으로 고정이기에 이 노드의 자식들의 자식노드 값이 더해지는 것을 기다릴 필요가 없으므로, 즉시 답을 비교하면 된다.
