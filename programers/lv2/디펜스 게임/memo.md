## [코딩테스트 연습 디펜스 게임](https://school.programmers.co.kr/learn/courses/30/lessons/142085)

---

우선은 enemy의 길이가 꽤나 기므로 k를 사용할 때 매 enemy마다 전체를 탐색해서 최대값을 빼는 것은 무리가 있다. 따라서 체크한 enemy 값을 저장하는 max heap을 사용해야겠다고 생각했다.

매 enemy를 heap에 저장하고, 저장한 후의 heap의 총합이 n보다 크다면 k를 사용하여 하나 씩 heapPop을 한다. 그러면 항상 이전 enemy 중 최대인 값을 제거할 수 있고 최대의 라운드를 통과할 수 있다.

heapPop을 할 때 heap의 길이가 1인 경우를 생각하지 않아서 오류가 발생했었다. 이 heap은 index 1부터 시작하며 index 0번은 Infinity로 두어 heapPush의 조건에서 다른 숫자가 0번을 침범하지 않도록 했다.

참고로 heap을 사용하지 않고 이분탐색을 이용하여 문제를 푼 다른 사람의 코드도 있다. 그 코드에서는 이분탐색으로 통과할 수 있는 라운드의 index를 찾는데, 각 index 마다 그때 까지의 모든 enemy를 정렬하고, k만큼을 지워 n 조건을 통과할 수 있는지를 찾는다. 이 이분탐색으로 찾은 index가 최대로 통과할 수 있는 라운드가 있는 index이다.

코드는 이분탐색쪽이 더 간결하지만, 매 탐색마다 sort가 있기 때문에 enemy가 매우 길어질수록 이분탐색쪽이 더 시간이 오래 걸리는것을 확인했다.
