## [선입 선출 스케줄링](https://school.programmers.co.kr/learn/courses/30/lessons/12920)

---

옛날 문제라 그런지 효율성 테스트 케이스가 같은 코드라도 제출할 때 마다 결과가 바뀐다. 처음엔 minHeap을 이용해 풀었었는데, 마지막 효율성 케이스 하나에서 계속 실패했다. 그런데 다른 케이스들 시간경과가 그리 크지 않은걸로 봐서는 케이스 자체에 뭔가 문제가 있는 것 같다.

좀더 효율적으로 코드를 만들기 위해 파라메트릭 서치를 사용했다. 파라메트릭 서치로 찾을 수 있는것은 특정시간에서 전체 작업이 처리될수 있느냐 없느냐이다. 그런데 이 문제는 좀더 구체적으로 정확히 몇 번째 코어가 마지막 작업을 수행할지를 찾아야 한다. 파라메트릭 서치로 통과 가능한 시간을 구했을 때, 그 시간에서 이미 n보다 많은 작업을 수행했을 가능성이 있다.

따라서 구해야 할 지점은 통과 가능한 시간의 정확히 1시간 전이다. 이는 합/불합 경계의 좌측이기 때문에 그에 맞춰 이분탐색의 경계를 잘 작성해주어야 한다.

통과 가능한 시간의 1시간 전의 시간을 구하면, 이 시간동안 몇 개의 작업이 수행되었는지를 구할 수 있다. 이 시간엔 전체 작업을 수행할 수 없으므로 n보다 작은 값이 나오고 몇 개의 작업을 더 수행해야 하는지를 알 수 있다.

여기서 정확히 1시간 후 모든 작업이 수행될것임을 알기 때문에, 이 시간을 core의 작업시간으로 나누었을 때 1이 남는 코어가 1시간 후 새로운 작업을 수행할 수 있는 코어이다. 이 코어들을 순차적으로 찾아가며 남은 작업수를 줄여주면 작업수가 0이 되었을 때 정확히 마지막 작업을 수행하는 코어를 찾을 수 있다.
