## [가장 먼 노드](https://school.programmers.co.kr/learn/courses/30/lessons/49189)

---

이 문제는 [등산코스 정하기](https://github.com/tkxksdl2/algorithms-js/blob/main/programers/lv3/%EB%93%B1%EC%82%B0%EC%BD%94%EC%8A%A4%20%EC%A0%95%ED%95%98%EA%B8%B0/memo.md) 문제와 매우 비슷하다. 다만 이 문제가 해당 문제보단 훨씬 쉬운 버전이므로 먼저 참조하면 좋을 것 같다.

조건은 아래와 같다.

1. 모든 경로는 동일한 weight를 지닌다. 이 경우 1이다.

2. 특별한 목적지가 없으므로 결국 모든 노드를 돌아야 할 것이다.

3. 출발지는 하나이며, 어떤 노드까지의 거리는 가능한 짧은 경로의 weight 합산이다.

일단은 이 문제 역시도 노드 개수가 매우 많아 모든 노드의 n\*n 거리 행렬을 만들기는 힘들다. 따라서 존재하는 노드 값만 넣어주어 어떤 노드에서 가능한 경로를 표현해주었다.

역시 BFS로 경로탐색을 했으며 경로의 가지치기는 1차원 배열로 각 노드에 도착할 수 있는 최소 weight를 갱신해가며 확인했다. 즉 경로를 탐색할 때 이미 그 경로가 더 짧은 weight로 갱신되었었다면,
더 짧은 경로가 존재하는 것이고 그 경로는 분기하지 않는다.

이 문제에는 특별한 목적지가 없으므로 어떤 노드에 도착할 때 마다 그 노드가 분기 조건을 만족한다면 (즉 효율적인 경로였다면) 매번 answer 값과의 비교도 일어나야 한다.

answer값의 갱신은 weight 합산이 더 크거나 같을 때 일어난다. 이는 문제에 맞추어 쉽게 생각할 수 있으므로 자세한 설명은 생략한다.
