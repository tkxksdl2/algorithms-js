## [N으로 표현](https://school.programmers.co.kr/learn/courses/30/lessons/42895#)

---

dp문제이지만 처음에는 이걸 어떻게 dp로 풀지 감을 잡지 못했었다. 그래서 가능한 사칙연산과 겹치기의 모든 조합을 만들어 앞에서부터 순서대로 계산을 해보는 방식으로 풀었지만 몇몇 케이스에서 성공하지 못했다.

그 방법을 사용할 때 괄호의 위치가 자유로우므로 곱셉과 나눗셈 연산의 순서에 상관없이 모든 연산의 조합을 확인하면 모든 순서를 확인할 수 있을 것이라 생각했다. 그러나 이러한 경우에는 순서대로 계산할 수가 없었다.

    4+(4*4)-(4/4)

뒷부분의 `-(4/4)` 부분은 어떻게 순서를 바꿔도 앞에서부터 계산하는 경우로 구현할 수가 없다. 이는 특히나 나눗셈과 뺄셈에는 순서가 존재하기 때문이다.

따라서 계산을 순서대로 하는것은 풀이가 될 수 없다. 대신 사용하는 숫자의 개수마다 각각의 연산 결과를 쌓아서 단계를 밟는 dp 방법을 사용할 수 있다.

숫자를 n 번 사용할 때의 연산 결과들을 map(n) 이라고 한다면, 각각의 map(n)에는 기본적으로 그 숫자를 n번 붙인 만큼의 기본 연산단위가 들어있다. 예를 들어 5를 한개 쓸 때는 5이고, 두 개 쓸 때는 55이다.

n이 1일때는 기본 연산단위 말고 다른 연산결과는 존재하지 않는다. 그러나 n이 2일때는 n이 1인 경우의 연산단위인 5끼리의 사칙연산 결과가 n의 연산결과로 들어간다. 즉. map(2) = map(1) Oper map(1)이다. 즉 기본값 55와 이전 단계의 결과인 5 끼리의 모든 사칙연산 결과가 map(2)의 연산결과이다. 이 방법은 숫자가 늘어나도 동일하며 다음과 같이 일반화할 수 있다.

    Oper는 각각의 사칙연산이다.
    n === 1, map(n) = [n];
    n >= 2,  map(n) = map(i) Oper map(n-i), i = (1,..., n-1);

이 방법으로 계속해서 n마다의 모든 연산결과를 구하고, 답이존재하는지를 찾으면 된다. 뺄셈과 나눗셈에는 순서가 있기 때문에 map(3) = map(1) Oper map(2), map(2) Oper map(1)과 같이 반대의 경우도 모조리 계산해줘야 된다는 점을 잊지 말자.
