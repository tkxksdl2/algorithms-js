## [이중우선순위 큐](https://school.programmers.co.kr/learn/courses/30/lessons/42628)

---

두 가지 다른 우선순위를 가진 큐를 구현하는 문제. 나는 이 문제를 풀기 위해서 실제로 두 가지의 큐를 사용했다.

이 문제는 heapPush와 heapPop을 기반으로 명령이 주어지므로, 값을 heapPush로 넣으면 꺼낼때도 일종의 정렬된 형태를 갖는다는 점에서 착안했다. 어떤 기준점을 잡고 그 값을 기준으로 큰 값은 maxheap에, 작은값은 minheap에 넣으면 각각의 별개의 큐에서 최대값과 최소값을 꺼내올 수 있다.

예를들어 처음 넣은 값을 5라고 한다면, 이 값을 기준점 baseLine으로 잡는다. 그 이후로 이 값보다 같거나 큰 값은 maxHeap에, 작은 값은 minHeap에 넣는다. 이렇게 하면 기준값까지 도달하지 않는 이상 max값과 min 값을 모두 접근할 수 있다.

그러다가 어떤 heap의 크기가 0이 되어 더이상 최소값 혹은 최대값을 참조할 수 없게되면, 나머지 큐에 남은 값이 있는지 확인하고 값을 전부 꺼내 두 개의 큐에 재분배한다. 이 때 재분배할 데이터들의 중간값이 새 baseLine이 되며, 이 값보다 같거나 큰 값은 maxHeap에, 작은값은 minHeap에 들어간다.

이는 vector 자료형이 크기가 한계에 도달할 때 크기가 2배가 되는 새 vector를 생성하는 모습에서 아이디어를 얻었다. 재분배할 큐가 클수록 재분배하는데에도 시간이 많이 걸리지만, 그만큼 오랫동안 재분배가 다시 일어나지 않을 것을 보장한다.

이 때 이전에 있던 baseLine은 꺼내진 걸로 간주하고 새 baseLine으로 대체된다. 만약 두 큐 모두에 값이 없는 상태였다면, baseLine은 undefined가 되고 다음에 처음으로 들어오는 값이 새 baseLine이 된다.

이것을 모두 반복한 후, 결과적으로 두 큐에 값이 남아있다면 heapPop을 이용해 최대,최소값을 가져오고, 값이 없다면 baseLine값을 가져온다. 만약 baseLine조차 없다면 모든 데이터가 pop 되었으므로 [0,0]을 리턴한다.

---

여담이지만 이 문제 효율성 조건이 까다로울 것 같았으나 정확성 테스트밖에 없어서 굉장히 싱겁게 풀렸고, 다른 사람들중엔 그냥 정렬을 써서 푼 사람도 많았다. 물론 문제 정의에는 맞지 않으므로 별로 좋아보이진 않았다.

추가로 나는 몰랐던 사실을 사용해 푼 사람도 있었으므로 그것도 기록한다.

그 풀이에서는 minHeap 하나만 사용했는데, minHeap의 경우 최소값이 가장 위에 있는 것이 당연하지만, 최대값은 리프 노드 중 하나에 있다는 것이 보장된다고 한다. 이 때 리프노드의 인덱스는 마지막 인덱스의 부모 인덱스 + 1 부터 끝까지이다.

따라서 그 풀이에선 minHeap을 사용하면서 최소값은 일반적인 heapPop, 최대값은 리프 노드를 순회하면서 최대값을 찾아 마지막 인덱스 위치와 스왑한 후 pop을 수행했다. 그쪽이 코드가 더 깔끔했으므로 흥미롭게 보았다.
