## [코딩테스트 연습 등대](https://school.programmers.co.kr/learn/courses/30/lessons/133500)

---

꽤 오랫동안 골머리를 썩힌 문제. 기본적으로는 tree 문제이나 이진트리가 아니므로 트리를 전체적으로 구축하는것이 힘들었다. 꽤나 나중에 깨달은 문제이지만 그냥 트리에는 최상단 root가 존재하지 않는다.

때문에 이 문제를 해결하려면 leaf 노드부터 시작해야만 했다. 문제 해결의 단서는 leaf에서부터 시작한다. leaf노드는 단 한개의 노드만 연결되어 있으므로, 리프노드와 그 다음 노드가 있을 때 어떤 경우에서든 리프노드가 아닌 다음 노드의 불을 키는 것이 더 같거나 적은 수의 불을 킨다.

따라서 개별 리프노드부터 시작하여 상위로 올라가야만 한다. 그런데 노드들의 상하구분이 정해져 있지 않고 순서에 따라 달라지므로, 나는 노드들의 구별을 위해서 각 노드와 연결된 노드들이 부모와 자식이 아니라 **방문되었거나 방문되지 않았거나**로 정의했다. 각 노드를 방문할 때 주변 노드 중 방문하지 않은 노드가 단 하나만 있다면 그것이 그 노드의 부모가 된다.

따라서 다음 노드를 작업 큐에 올릴 때도 이것을 참조한다. 한 노드가 다음 부모 노드를 바로 작업 큐에 올린다면 이 부모노드에게는 방문되지 않은 잠재적인 자식 노드가 존재할지도 모른다. 따라서 작업 큐에 올라갈수 있는 노드는 현재 방문되지 않은 주변 노드가 단 하나인 노드이다.

불을키는 조건은 더욱 간단하다. 주변 노드들 중 이미 방문된 노드 (즉 자식 노드)들 중 불이 켜지지 않은 노드가 하나라도 있다면 이 노드는 불을 켜야한다. 그렇지 않다면 불을 키지 않아도 된다. 리프노드는 자식 노드가 없으므로 불을 키지 않는다.

이 방법대로면 리프노드에서 가장 최선의 이득을 보고, 상위로 올라가면서 꼭 필요한 부분에서만 불을 키기 때문에 항상 최소의 횟수를 보장한다.
