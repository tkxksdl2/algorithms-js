## [카운트 다운](https://school.programmers.co.kr/learn/courses/30/lessons/131129)

---

처음엔 target을 가능한 한 60으로 채우고 cnt와 sb(single 혹은 bull의 개수)를 최적화 하는 전략을 사용했었다.

이 때 이전 단계의 60을 50 bull로 바꾸는 경우의 수가 있었는데, 이에 따라서 남은 숫자의 조건에 따라 cnt와 sb를 더해주었었다.

하지만 이 방법의 경우 조건이 매우 직관적이지 않고, 더 세밀한 경우의 수를 따질 수가 없었다. 최종 점수 92점이 나왔으므로 다른 방법을 사용하기로 했다.

때문에 dp 방법을 사용하였으며 dp[i]는 target이 i 일 때의 [cnt, sb]를 의미한다.

처음엔 한 번의 다트로 만들 수 있는 점수를 초기화해둔다. 이는 1~20 까지 싱글, 50에서 불, 그리고 1~20의 더블 혹은 트리플로 만들 수 있는 숫자이다. 초기화되지 않은 나머지 점수는 [Inifinity, 0]이다.

이후로는 두 번 이상의 다트로 만들 수 있는 점수를 만든다. 점수의 조합으로 만들 수 있는 숫자는 21번부터이기 때문에, 20을 기준점 i로 잡고 해당 기준점과 기준점 이전의 다트 점수 j 와 조합하여 만들 수 있는 점수 i+j 를 모두 갱신한다. 이 때 갱신되는 조건은 cnt가 더 작거나, cnt는 같은데 sb가 더 클 경우이다.

이 때 한 번의 다트로 만들 수 있는 최대 점수가 60점이기 때문에, 기준점에서 60점 아래인 점수는 조합할 필요가 없다. 1부터 60 까지 조합되지 않은 원소 값의 점수가 존재하고, (물론 이 사이에도 29와 같이 조합된 숫자가 있지만, 조건을 만드는 것이 더 까다로우므로 원소 값이라고 생각해도 무방하다.) 이로부터 다음 인덱스들은 이전 값의 조합에 의해 생성된다. 따라서 어떤 기준점에서 60이 차이나는 점수는 이미 그렇지 않은 점수들의 조합에 쓰여 있으므로 중복되어 굳이 검사할 필요가 없다.
