## [아방가르드 타일링](https://school.programmers.co.kr/learn/courses/30/lessons/181186)

---

점화식을 세우는 것이 굉장히 까다로운 dp문제이다.

이 문제의 첫 번째 난관은 모든 원소값을 찾는 일이다. 이 문제에서 원소값이란 특정 n에서 더이상 다른 n 단계의 배치로 나눌 수 없는 경우를 뜻한다. n이 1, 2, 3인 경우에서 원소값은 쉽게 찾을 수 있다.

1에서 원소값은 1개, 2에서는 2개, 3에서는 5개이다. 이는 문제에서 제공하는 케이스 중 더이상 나눠지지 않는 케이스를 확인하면 알 수 있다.

문제는 n이 4 이상인 경우인데, 예를들어 n이 4 일때 다음과 같은 원소값이 존재한다.

    1 1 1 2
    3 3 2 2
    3 4 4 4

이 원소값을 좌우 반전하여 총 2가지의 원소값이 존재한다. 그런데 이것과 동일한 형태가 블럭의 추가로 n이 7일 경우에 나타날 수 있다.

    1 1 1 5 5 5 2
    3 3 6 6 6 2 2
    3 7 7 7 4 4 4

이 경우를 보면, 이 또한 더이상 나눌 수 없는 원소값이고, 3개의 가로 일자블럭이 계단형으로 추가되어서 늘어난 것을 볼 수 있다.

        5 5 5
      6 6 6
    7 7 7

이러한 구조는 가로로 무한정으로 늘어날 수 있다. 늘어날 때 마다 가로 3칸을 소비하므로, 즉 이러한 구조가 n이 3 늘어날 때 마다 반복된다고 할 수 있다.

또한 이 구조가 정상적인 직사각형 형태로 마감되기 위해서는 끝 부분에 ㄴ 모양의 블록이 들어가야 한다. 이러한 구조를 만는 방법 역시 두 가지이다.

    1 1    1 1 1
    1      2 2
           2

여기서 어떤 구조를 사용하느냐에 따라서 총 길이가 달라진다. 작은 것을 두개 쓰면 길이가 추가되지 않고, 큰 것을 하나 쓰면 길이가 1 추가, 두 개 쓰면 길이가 2 추가된다. 즉 이 경우의 수가 숫자 3 마다 돌아가면서 나온다는 의미이다. 이 때의 경우의 수는 작은 것을 두개 쓰거나 큰 것을 두개 쓸 때 좌우반전을 생각해서 2개의 원소값이 나오고, 각각 하나 씩 쓸 때는 좌우반전과 사용순서를 생각해 2\*2=4개의 원소값이 나온다.

이때 n=4일때는 큰 ㄴ자를 두 개 쓴 모양이고, n=5일때는 작은 것을 두 개 쓴 모양이다. 그렇다면 순서대로 n=6일때는 각각 하나 씩 쓴 모양이 될 것이다.

    n=4         n=5            n=6
    1 1 1 2     1 1 2 2 2      1 1 1 3 3 3
    3 3 2 2     1 3 3 3 5      2 2 4 4 4 6
    3 4 4 4     4 4 4 5 5      2 5 5 5 6 6

따라서 n이 4일때부터는 원소값의 개수가 2, 2, 4, ... 로 반복되어 나타난다는 뜻이다.

그러므로 원소값의 map은 n이 6일 경우 까지만 저장해도 된다.

이제 이 값을 이용해서 dp를 시행해야 한다. n이 늘어날 때 마다, 이전 단계에서 우측의 빈 공간으로 원소 값을 추가해나가며 늘린다고 생각하자.

예를 들어서 우측으로 한 칸을 늘린다고 한다면, dp[n-1]값을 그대로 가져올 수 있다. 우측으로 두 칸을 늘린다고 한다면, dp[n-2] 값에서 n이 2 일떄의 원소값 elementMap[2]을 곱해서 경우의 수를 구할 수 있다.

이를 dp[n]의 관점에서 볼 때, dp[n]이란 이전 단계 중 하나에서 원소값을 우측에 추가해 총 길이가 n이 되었을 경우의 수의 총합이다. 그런데 위에서 원소값을 정의할 때 사실상 모든n에 원소값이 있었던 것을 알 수 있다.
따라서 dp[n]을 만들기 위해선 이전 단계 전부를 참조해야 한다.

물론 그런짓을 하면 시간이 훌쩍 넘어갈 것이 당연하므로 n이 4 이상인 경우는 같은 원소값 개수를 가지는 것 끼리 묶어서 계산을 해야 한다. 예를 들어서 dp[n-4]와 dp[n-7]은 같은 원소값 계수 2를 가진다. dp[n-5]와 dp[n-8]도 마찬가지고, dp[n-6]과 dp[n-9]는 같은 원소값 계수 4를 가진다. 이는 당연히 원소값들이 나타나는 규칙 때문이다.

따라서 각 규칙이 시작되는 n-4, n-5, n-6 지점에 대해서 그 지점까지의 모든 경우의 수를 3단계마다 저장하는 accMap이 필요하다. 즉 accMap[n-4]는 n-4 지점과 같은 원소값 규칙을 가지면서 n-4보다 작은 지점들의 경우의 수의 총합이다. 이 accMap을 이용하여 세 가지의 경우의 수를 해결해주면 지점 n에 대해서 elementMap의 총 개수인 6번의 연산만 수행해주면 된다.

---

## 처음에 틀렸던 이유

최초에 dp 규칙을 세울 때, 원소 블럭들이 우측이 아니라 양 쪽에 추가될 수 있는것으로 생각하고 각 경우의 수에 \*2를 했었다. 때문에 dp[n-1] 을 채울 때는 모든 블록이 세로 일자블럭일 경우을 감안해 -1을 해주었었다.

허나 이 방법이 n이 커질수록 중복을 무지막지하게 많이 만든다는 것을 뒤늦게 깨달았다. 추가할 원소값의 길이가 i라면, (n-i의 경우의 수 \* i의 원소값) 의 식이 사용되는데, 이것이 양쪽에 추가되므로 정 반대의 상황 (i의 경우의 수 \* n-i의 원소값) 을 추가할 때 (i의 원소값 \* n-i의 원소값) 만큼의 중복이 생성된다.

이러한 식은 i가 1, 2, 3일 때는 중복제거를 일일히 해줄 수 있었지만, i가 4 이상이 되면 각 경우의 수를 총합해서 계산하므로 중복제거를 적용할 수가 없었다.

dp에서 규칙을 세울 때는 순서나 방향 등 명확한 기준을 가지고 하는 것이 유리하다는 교훈을 얻었다.
