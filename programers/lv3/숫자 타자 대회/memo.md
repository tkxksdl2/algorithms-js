## [숫자 타자 대회](https://school.programmers.co.kr/learn/courses/30/lessons/136797)

---

각 숫자까지의 이동거리를 구하는 것은 매우 쉬웠지만, 어떻게 매 단계마다 최적화를 보장할지가 상당히 어려운 문제였다. 나도 해당 문제를 dp 혹은 greedy로 풀 수 있을거라 생각했지만 방법을 쉽사리 떠올리지 못했다. 힌트를 참고해 dp를 구현하고, 기존에 실패했던 코드에 greedy로 짠 다른 사람의 코드를 참고하여 재설계해서 모두 구현에 성공했다.

먼저 dp를 살펴보면, weights의 index i,j는 각 단계에서 출발 가능한 손가락 위치의 조합이고 값은 해당 위치의 누적값이다. 이 경우 각각의 시작위치가 이미 목표 위에 있는 경우와 그렇지 않은 경우로 나뉜다. 시작위치가 목표 위에 있는 경우는 w + 1이되고, 그렇지 않은 경우는 함수로 다음 w값을 구한다. 물론 값이 더 작을 경우에만 저장한다.

이 경우 각각의 손가락이 어떤 버튼을 누를 때 마다 반대 손가락에도 동일한 weight로 다음 단계를 진행할 가능성이 생기므로, 손가락이 i에서 n으로 이동하면 다음 위치는 반대 손가락인 j와 이동한 위치인 n이 된다.

그런데 이 방법을 쓰면 weights는 10\*10 의 배열이 되는데, 손가락의 순서는 그다지 상관 없어 바뀔 수 있으므로 특정 위치 조합 i, j를 검사할 때 j, i 조합도 검사해야 하기 때문이다. 이는 불필요한 연산과 메모리를 사용하므로 바람직하지 못하게 생각되었다.

이때문에 배열을 1차원 10 길이로 줄여서 관리할 수 없을까 해서 접근한 방법이 greedy 방식이다. 이 방식에서 weights는 10 길이의 1차원 배열이고, 각 i 위치에는 누적된 w값과 다른 손가락의 위치를 담고 있다. 이 방식이 가능한 이유는 맨 처음을 제외하고 항상 두 손가락 중 하나는 이전 목표 위치값을 가지고 있기 때문이다. 즉 경우의 수를 항상 10개 이하로 만들 수 있다.

따라서 어떤 i와 이전 i 값인 otherI가 있을 때, 반대 쪽 i가 목표 위에 있지 않다면 해당 i를 목표 위치로 옮긴다. 어떤 i가 이미 목표 위에 있다면 그 i만을 움직여야 한다. 이 방법이면 매 단계에서 목표 위치로 이동 가능한 경우의 수를 모두 확인할 수 있고, 그중 가장 작은 값을 저장한다. 다음 단계의 otherI는 항상 목표 위치인 n값이 된다.

사실 greedy나 dp방식이나 접근방식은 크게 다른 것 같지 않다.
