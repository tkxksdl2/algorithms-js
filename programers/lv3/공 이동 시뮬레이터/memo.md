## [공 이동 시뮬레이션](https://school.programmers.co.kr/learn/courses/30/lessons/87391)

---

얼핏 보면 공 하나하나의 이동경로를 계산해야 할 것 같지만, 문제에서 테이블의 크기가 매우 크고 여러 위치의 공이 결과 x,y에 도착할 수 있기 때문에 이는 불가능하다.

중요한 점은 특정위치의 **가능한 공의 개수** 를 구하는 것이기 때문에 공 하나의 이동경로를 보기보다는 테이블 전체를 두고 봐야 한다. 그래서 시작에 모든 위치에 공을 두고, 모든 공이 각 쿼리에 따라 동일하게 움직인다고 가정하자.

공을 위로 한 칸 올리라는 쿼리를 사용하면 위와 같이 동작할 것이다.

    1 1 1 1 1        2 2 2 2 2
    1 1 1 1 1        1 1 1 1 1
    1 1 1 1 1   ->   1 1 1 1 1
    1 1 1 1 1        1 1 1 1 1
    1 1 1 1 1        0 0 0 0 0

이번엔 공을 우측으로 움직이라는 쿼리를 사용하면 이렇게 동작한다.

    2 2 2 2 2        0 2 2 2 4
    1 1 1 1 1        0 1 1 1 2
    1 1 1 1 1   ->   0 1 1 1 2
    1 1 1 1 1        0 1 1 1 2
    0 0 0 0 0        0 0 0 0 0

무언가 형태가 보일 것이다. 이 문제는 사실 공 하나의 이동경로를 계산하는 문제가 아니고, 균일하게 배치된 공들을 쿼리에 따라 일정하게 뭉치는 작업을 하는 것이다.

처음 배치된 공의 사각형은 전체 테이블의 크기와 같다. 이 때 위로 한칸 쿼리를 사용하면 공의 사각형의 y값이 1 작아지며, 그만큼 맨 위쪽의 외곽선에 더해진다. 이렇게 쿼리를 사용해 공의 사각형이 전체 테이블의 범위를 벗어나서 움직일 때 마다 공이 뭉쳐진다.

이러한 사실에 기인해 이 문제는 여러 방식으로 풀 수 있다. 쿼리를 순서대로 실행하며 전체 공을 뭉치는 작업을 하던가, 반대로 쿼리를 역순으로 실행하여 마지막 위치의 공을 펼치는 작업을 하는 것이다.

---

나는 공을 뭉치는 방법으로 문제를 풀었지만, 공을 펼치는 작업으로 문제를 푼 사람들이 많아 간단하게 설명을 작성한다.

펼치는 경우엔 다음과 같다. 어떤 공이 우로 두 칸 이동하라는 쿼리를 진행한 후 다음과 같은 위치에 있다고 하자.

    0 0 0 0
    0 0 0 x
    0 0 0 0

이 공의 쿼리 이전 위치는 이러할 것이다.

    0 0 0 0
    0 x 0 0
    0 0 0 0

그런데 마찬가지로 테이블에는 이 공만 존재했던 것이 아니다. 모든 위치에도 공이 하나 씩 존재했을 것이다. 그리고 각 공들은 벽을 벗어날 때 다른 공과 뭉쳐진다.

이 공은 해당 쿼리에 의해 벽에 도달했고 따라서 공 x는 우측으로 두칸 이동하면서 자신 우측에 있는 공 두개와 뭉쳐졌을 것이다. 따라서 공 x의 위치는 초기 테이블에서 공의 위치 범위로 나타낼 수 있고 이는 이렇게 나타낼 수 있다.

    0 0 0 0
    0 x x x
    0 0 0 0

마찬가지로 이 쿼리 이전에 위로 한칸 이동하라는 쿼리가 존재했었다고 치자. 그렇다면 공의 범위는 이러했었다.

    0 0 0 0
    0 0 0 0
    0 x x x

이 경우엔 공이 뭉쳐지지 않았었다는 것을 알 수 있다. 맨 위 열의 공은 뭉쳐졌을 수도 있지만 이는 마지막 x 위치의 공과는 전혀 관련이 없다.

마지막으로 이 쿼리 이전엔 아래로 한 칸 이동하라는 쿼리가 존재했었다고 치자. 첫 번째 쿼리와 마찬가지로 이 공은 해당 쿼리로 인해 벽에 도달했고 그로 인해 공들이 뭉쳐졌을 것이다.
그렇다면 공의 볌위는 이러할 것이다.

    0 0 0 0
    0 x x x
    0 x x x

이것이 최종적으로 x 위치에 놓인 공들이 어디서부터 뭉쳐졌는지를 나타내는 x의 범위이고, 이 범위의 넓이를 구하면 x 위치의 공의 개수를 구할 수 있다.

즉, 쿼리를 역순으로 실행하면서, 어떤 공이 쿼리로 인해 벽에 부딪혔다면, 그 역으로 공의 범위를 늘려나가는 식으로 공의 위치를 범위를 구하는 방식이 공을 펼치는 방식이다.

---

나는 공을 뭉치는 방식으로 문제를 풀었는데, 공을 펼치는 방식보다 여러모로 코드가 길고 조건문이 복잡해졌다. 대신 이 방식으로는 한번의 쿼리 순회 후 모든 위치의 공의 개수를 구할 수 있다는 장점이 있다.

처음으로 돌아가 공이 뭉쳐지는 방식을 확인하면 다음과 같다.

    2 2 2 2 2        0 2 2 2 4
    1 1 1 1 1        0 1 1 1 2
    1 1 1 1 1   ->   0 1 1 1 2
    1 1 1 1 1        0 1 1 1 2
    0 0 0 0 0        0 0 0 0 0

여기서 공이 한번 더 위로 움직인다면 이러한 모습이 될 것이다.

    0 2 2 2 4        0 3 3 3 6
    0 1 1 1 2        0 1 1 1 2
    0 1 1 1 2   ->   0 1 1 1 2
    0 1 1 1 2        0 0 0 0 0
    0 0 0 0 0        0 0 0 0 0

마지막으로 아래로 한번, 좌로 한번 움직인다면 이러한 모습이 될 것이다.

    0 0 0 0 0
    3 3 3 6 0
    1 1 1 2 0
    1 1 1 2 0
    0 0 0 0 0

여기서 몇가지 중요한 포인트를 잡을 수 있다.

1. 공의 범위는 처음 테이블과 같으나 공이 뭉쳐질 때 마다 작아진다.

2. 공 범위 사각형의 외곽선 부분에서 공이 일괄적으로 뭉쳐지며, 같은 외곽선이면 모두 값이 같다.

3. 외곽선이 겹치는 꼭지점 부분의 값은 각 외곽선의 값의 곱이다.

4. 공 범위 사각형이 테이블 범위를 벗어나지 않으면 공은 뭉쳐지지 않고, 사각형의 위치만이 변한다.

따라서 공 사각형의 시작점과 끝점, 네 부분의 외곽선의 값을 저장해두고 쿼리에 따라 갱신해나가면 최종 테이블에서 공 사각형의 위치와 테이블 각 위치의 숫자까지 정확하게 알 수 있다.

외곽선의 값은 tdlr이라는 배열에 저장했으며, 각각 상,하,좌,우 외곽선의 공 개수를 저장해두었다. 여기서 공 개수란 해당 방향으로 몇 번 테이블 밖으로 나가 공이 뭉쳐졌는가를 말한다. 초기엔 모두 값이 1일 테지만 위로 두번 뭉쳐졌다면 [3,1,1,1]이 될 것이다.

이후 쿼리에 따라 공 사각형을 움직인다. 이 때 공 사각형이 전체 테이블의 범위를 벗어난다면 공이 뭉쳐졌다는 의미이다. 몇 칸이나 벗어났는지에 따라 해당 방향 외곽선의 값에 그만큼 더해준다. 그리고 벗어난 공 범위를 테이블 제한구역 내로 갱신해준다.

이렇게 모든 쿼리를 실행하고 나면 최종 결과인 공 사각형의 범위와 위치, 각 외곽선에 공이 몇 번 뭉쳐졌는가를 알 수 있다.

여기서 알아내야 할 위치 x,y가 공 사각형 외부라면 0, 외곽선이 아닌 공 내부라면 1, 외곽선 위치라면 tdlr의 해당 값, 꼭지점이라면 해당 위치의 tdlr값들의 곱을 리턴해주면 된다.

여기서 주의할점은 꼭지점 위치의 경우 10^9 \* 10^9 의 큰 연산이 사용되므로 오버플로우 방지를 위해 BigInt를 사용해야 한다.
