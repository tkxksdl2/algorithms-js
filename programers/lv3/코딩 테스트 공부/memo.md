## [2022 KAKAO TECH INTERNSHIP 코딩 테스트 공부](https://school.programmers.co.kr/learn/courses/30/lessons/118668)

---

다익스트라를 활용해 최소 경로 문제로 변환하는 문제이다. 이 문제를 다익스트라로 변환하는것은 힌트를 참조했다. 이것을 최소경로 문제로 생각하기 위해서는 약간의 사고가 필요했다.

언뜻 보면 DFS나 BFS를 사용하여 초기 상태에서 여러 problems를 선택하고 그것을 다음 단계에 저장하는 식으로 생각할 수 있다. 하지만 이 방법으로는 너무 많은 노드가 생길 위험이 있고 무엇보다 같은 위치에 다른 시간을 가진 여러 노드가 중복될 수 있다. 더 나중에 생긴 노드가 저장 시간이 높다면 노드를 생성하지 않으면 되지만, 반대의 경우 미리 만들어둔 노드를 지우기 위한 또다른 연산이 필요하다. 즉 어떤 상태에 있을 때 그 상태의 최소 시간을 저장하는 배열이 또 필요하다.

생각을 뒤집어 alp와 cop의 어떤상태를 노드라고 하고, 각 problems를 간선이라고 하면, 최소시간을 저장하는 배열을 만들고 방문 순서대로 최소시간을 갱신하는 법으로 다익스트라 풀이가 가능하다. 다행히도 노드끼리는 명확한 순서를 가지고 있기 때문에 낮은 인덱스부터 순서대로 순회하는것 만으로도 항상 최소시간을 갱신할 수 있다.

마지막으로 고생을 했던 부분은 넘어가는 인덱스에 관한 부분이다. 이 문제는 정확한 도착지점이 정해져 있지 않고 max 인덱스보다 크기만 하면 되므로, 최적인 정답이 max보다 한참 떨어져 있거나, 떨어진 지점에서 몇 단계를 더 뛰어야 하는 경우도 생긴다. 처음엔 최소시간 index 크기를 키워보았지만, 간선의 진행이 [150,2] 같이 극단적인 경우 몇 단계를 뛰어야 할지 알 수가 없고 비효율적이다.

이것은 생각보다 간단하게 풀렸는데, alp와 cop 중 이미 목표를 달성하고 넘어간 부분은 max에 있는것과 동일하게 저장하면 된다. 이 역시도 노드끼리의 순서가 명확하여 되돌아갈 일이 없기 때문에 가능한 구현이다. 즉 목표가 [10,10] 일 때, [15,9] 인 위치가 [10,9] 인 위치보다 시간이 빠르다면 이를 [10,9] 위치에 저장하는 것도 논리상 아무 문제가 없다.
