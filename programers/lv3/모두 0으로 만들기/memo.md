## [모두 0으로 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/76503)

---

문제 조건인 **- 임의의 연결된 두 점을 골라서 한쪽은 1 증가시키고 한쪽은 1 감소시킨다.** 라는 말은 값을 1씩 인접 노드로 이동시킨다는 말과 동일하다. 따라서 모든 노드를 0으로 만들려면 전체 노드의 가중치 값을 모두 더했을 때 0이 되어야만 한다. 우선은 이 경우를 필터링하는 것으로 시작한다.

모든 가중치 값은 가장 가까운 반대 값으로 이동할수록 좋다. 그런데 이 문제의 그래프는 트리일것이 보장되므로 각 노드 사이에는 하나의 길밖에 존재하지 않는다. 이 때 특정 노드를 루트노드로 하고 부모자식 관계를 지정할 때 모든 가중치는 부모 쪽으로 이동함으로써 다른 가중치 값을 만날 수 있다.

부모-자식관계인 노드의 경우 부모에서 자식 쪽으로 이동할 수도 있지만 이 이동으로 모든 가중치가 소모된다는 보장이 없다. 소모되지 않았을 경우엔 남은 가중치는 계속해서 이동하여 부모-자식관계가 아닌 형제 혹은 조상 노드의 가중치와 만나야 하는데 그러기 위해서는 무조건 부모 노드를 거쳐야만 한다. 따라서 이동횟수를 최소화하기 위해 가중치는 항상 부모 노드 쪽으로 이동한다.

         3                3             0
      -2   2      =>  -4     1    =>
    -2      -1

따라서 리프 노드부터 시작하여 자신의 가중치 값을 계속해서 부모로 전달하여 루트 노드에 도달하면 총 이동횟수를 구할 수 있다.

이때 깊이가 가장 깊은 리프노드부터 전달을 시작해야 하는데 그 이유는 특정 노드의 가중치 값이 부모로 전달될 때 그 가중치 값이 자신의 자식 서브트리의 모든 가중치 값을 이미 전달받았음을 보장해야 하기 때문이다.

---

먼저 bfs를 통해 트리의 깊이에 따라 순서대로 노드를 기록한다. 이 때 이진트리가 아니라 루트 노드는 지정되어있지 않으므로 항상 존재하는 0번 노드를 루트 노드로 만든다.

그리고 기록된 노드를 다시 역으로 탐색하며 자신의 부모 노드에 자신의 가중치 값을 전달하고, 전달된 절대값만큼 이동횟수에 더해준다. 이렇게 루트 노드에 도달하면 최소 이동횟수를 구할 수 있다.

이 떄 가중치 값이 매우 클 수 있으므로 몇몇 케이스에서는 오버플로우가 발생할 수 있다. 따라서 최종 answer는 bigInt를 사용해 기록해야만 전체 케이스를 통과할 수 있다.
