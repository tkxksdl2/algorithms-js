## [거스름돈](https://school.programmers.co.kr/learn/courses/30/lessons/12907)

---

쉬운 dp 문제인데 길을 잘못들어서 시간을 오래 끌어버렸다.

기본적으로 금액 n을 만드는 경우의 수는 다음과 같이 구할 수 있다.

금액 n과 화폐 m에 대해서, dp[n] += dp[n-m]

이는 특정 금액 n-m에서 화폐 m을 한개 더 사용해서 금액 n을 만드는 경우의 수를 의미한다. 작은 금액부터 n까지 모든 화폐에 대해 이를 반복한다면 경우의 수를 쉽게 구할 수 있다.

내가 길을 잘못 든 부분은 반복의 순서에 있다. 나는 금액 n에 대한 순회 -> 화폐 m에 대한 순회를 진행했다. 이는 즉 금액 ni에 대해 모든 ni-mi를 한꺼번에 진행한다는 의미이다. 그런데 이렇게하면 경우의 수에 중복이 발생한다.

예를들어 화폐 1, 2 로 3을 만드는 경우를 살펴보면 아래와 같다.

    n   1   2   3
    dp  1   2   2+1=3

3을 계산하기 위해선 1원에 화폐 2를 더하는 경우와, 2원에 화폐 1을 더하는 경우를 모두 살펴본다. 이때 화폐 2를 만드는 경우는 (1,1), (2) 로 총 두가지 경우인데, 동전으로 금액을 만드는 것은 순열이 아닌 조합이기 때문에 1 + 2나 2 + 1이나 똑같은 경우가 된다. 그러면 아래와 같은 경우로 중복이 생기는 것을 알 수 있다.

    (1,2), (1,1,1), (2,1)

따라서 문제를 제대로 풀려면 각 화폐를 순차적으로 더해주어야 한다. 즉 화폐 m에 대한 순회가 금액 n에 대한 순회보다 먼저 등장해야 하며, 이 경우 아래와 같이 dp가 진행된다.

    m=1
    n   1   2   3
    dp  1   1   1

    m=2
    n   1   2   3
    dp  1   2   1+1=2

모든 화폐의 순회를 한꺼번에 진행하면 이전 단계의 경우의 수에 화폐 m이 몇 개 존재하고 있는지 알 수가 없으므로 이번 단계에 더해지는 경우의 수가 완전히 새로운 경우의 수라는 보장이 없다.

그러나 화폐 m에 대한 순회를 먼저 진행하면 이번 순회에서 화폐 m이 처음으로 등장한것이 되므로, 어떤 경우의 수에 m이 더해졌을 때 항상 새로운 경우의 수임을 보장한다. 따라서 중복이 제거된다.
