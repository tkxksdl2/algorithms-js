## [억억단을 외우자](https://school.programmers.co.kr/learn/courses/30/lessons/138475)

---

어떤 숫자가 억억단에서 나오는 횟수는, 그 숫자의 약수의 개수와 같다. 예를들어 8의 약수는 1, 2, 4, 8로 4개인데, 이는 즉 8이라는 숫자가 1\*8, 2\*4, 4\*2, 8\*1 에서 총 네번 등장한다는 의미이다.
0
이렇게 모든 숫자의 약수가 있을 때, 찾아야하는것은 s부터 e 구간까지 약수의 갯수가 최대인 숫자 중 가장 작은 숫자이다. e의 위치는 고정되어 있고 s가 작아질수록 목표하는 숫자도 점점 작아진다. (e와 s가 같을 때 목표 숫자는 e 자신이며, s가 작아질수록 목표 숫자는 e보다 작거나 같다. 그러나 커질수는 없다.) 때문에, 이 숫자를 e에서부터 s까지 역으로 찾아갈 수 있다.

나는 일반적인 약수를 구하는 방식으로 약수의 개수 리스트를 만들었었다. (각 숫자 n 마다 1부터 Math.squrt(n) 까지 나누어 보는 방식) 그러나 이 방식은 1부터 e 까지 모든 숫자마다 sqrt(n) 번의 연산이 필요하기 때문에 숫자가 커질수록 연산이 너무 많이 걸려 더 효율적으로 약수를 구하는 방식이 필요했다.

따라서 모든 수의 약수를 구하기 보다, 1부터 e 까지를 순회하며 해당 숫자를 곱해 만들수 있는 숫자 자리에 +1을 해가며 약수의 개수 리스트를 만들었다. 이 방식으로는 1부터 e 까지 숫자마다 e/n 번의 연산으로 모든 약수의 개수를 구할 수 있다.

숫자가 매우 커질수록 n=(1;n\<=e; i++)의 sqrt(n)의 합 보다 e/n의 합이 훨씬 작아진다.
좀 더 단순하게 생각하면 첫 번째 방식의 경우 n이란 숫자에서 1부터 sqrt(n) 까지의 모든 숫자를 검사하며, 이중에는 약수가 되지 않는 숫자가 포함되어있을 수 있다. 하지만 두 번쨰 방식의 경우 해당 숫자를 곱해 만들 수 있는 자리에 +1을 하므로 모든 순회가 약수를 만드는 데에 영향을 끼친다. 즉 낭비가 없이 정확히 약수의 총 개수만큼만 순회를 돈다는 의미이다.
