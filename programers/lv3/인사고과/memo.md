## [인사고과](https://school.programmers.co.kr/learn/courses/30/lessons/152995)

---

정렬을 잘 사용해야 하는 문제. 문제 조건 중 과락 조건을 어떻게 찾아야 할지 골머리를 썩혔다. 혼자서는 쉽게 떠올리지 못해서 다른 사람의 코드를 많이 참조했다.

먼저 참고할 점은 어떤 사원이 과락이려면 다른 사원보다 두 점수가 모두 낮아야 한다는 점이다. 때문에 점수의 총합이 낮더라도 특정 점수가 더 높다면 과락이 아니다. 그러나 점수 총합이 더 높다면 총합이 더 낮은 사원에 의해서 과락될수는 없다.

당연히 모든 사원을 상호비교하는것은 시간 초과가 발생한다. 때문에 가급적 한 번의 순회만으로 문제를 해결해야 하므로, 일단은 scores를 정렬해야 했다. 문제는 어떻게 정렬하느냐이다. 처음에는 점수 총합을 이용해서 정렬했는데, 이 경우 순위를 구할 수는 있지만 특정 사원의 과락 여부를 확인하기에 어려움이 있었다. 때문에 점수 각각을 활용한 정렬이 필요했다.

때문에 우선 첫 번째 점수를 활용해서 내림차순 정렬을 한다. 이 경우 더 높은 점수가 앞에 오므로, 자연스레 큰 점수부터 검사를 할 수 있다. 그리고 차례로 이 점수를 활용해 target이 과락인지, 이 점수가 target보다 앞에 있는지 확인한다. 어떤 점수가 두 점수 모두 target보다 크다면 target은 과락이므로 -1을 리턴하고, 두 점수 모두 크지는 않은데 총합이 더 크다면 이 점수가 target 보다 앞에 있으므로 answer에 +1을 해준다.

그런데 여기에는 검사하는 각각의 점수가 과락인지 아닌지를 확인하는 로직이 없다. 이를 위해서 첫 번째 점수가 같은 경우 두 번째 점수를 오름차순 정렬을 해주어야 한다. 그리고 매 검사마다 과락되지 않은 사원의 두 번째 점수를 저장하여 저장된 값과 현재 사원의 두 번째 점수 값을 비교하여 점수가 더 크거나 같을 때만 위의 로직을 수행한다. 즉 점수가 저장된 값보다 작다면 그 사원은 과락이다.

왜 두 번째 점수를 비교하는것이 과락인지 아닌지를 결정할 수 있는 것일까? 첫 번째 점수가 내림차순 정렬이기 때문에 다음 사원의 첫 번째 점수는 항상 작거나 같다. 과락의 기준은 두 점수 모두 낮아야 하는 것이므로, 첫 번째 점수가 더 커지지 않는 것을 보장한다면 두 번째 점수와 마지막으로 과락되지 않은 사원의 두 번째 점수의 비교만으로도 과락 여부를 결정할 수 있다.

여기엔 또 두 가지 경우가 있는데, 만약 다음 첫 번째 점수가 더 작은 경우, 다음 나올 사원이 과락이 아니려면 두 번째 점수는 마지막으로 과락되지 않은 사원의 두 번째 점수 값보다 크거나 같아야 한다. 하지만 첫 번째 점수가 같다면, 두 번째 점수가 더 작더라도 과락이 아닐 수 있다. 이 때 두 번째 점수가 오름차순 정렬되어 있지 않다면 처음에 너무 큰 값이 저장되어 과락되지 않아야 할 사원이 과락될 수 있다. 때문에 두 번째 점수를 오름차순 정렬하여 작은 값부터 검사해 과락이 아닌 모든 사원을 검사할 수 있도록 하는 것이다.
