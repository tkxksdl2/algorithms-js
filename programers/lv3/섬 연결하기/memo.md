## [섬 연결하기](https://school.programmers.co.kr/learn/courses/30/lessons/42861)

---

우선 n이 충분히 작기 때문에 모든 경로를 완전탐색하기가 용이하다. 그 이후로는 그리디 방식을 사용했는데, 무엇을 기준으로 최적화할지가 중요했다.

어떠한 섬이 '연결' 된다는 것은 이미 연결된 섬의 집합에 주어진 경로 중 하나의 비용을 지고 집합에 포함되는것을 말한다.
그리고 이렇게 섬이 연결될 때 가능한 한 적은 비용을 사용해 연결될수록 좋다.

만약 어떤 섬이 집합에 연결되고자 한다면, 가능한 적은 비용을 사용해 연결되어야 한다. 그런데 특점 섬을 지목해 집합에 경로를 조회할 떄, 가능한 최소 경로가 집합에 아직 포함되지 않은 섬을 지목하고 있을 수가 있다. 이 때문에 경로가 섬을 추가하는 순서에 영향을 받게 되고, 이는 최적을 보장하지 않는다.

따라서 경로의 조회는 이미 집합에 포함된 섬을 기준으로 뻗어나가야 한다. 즉, 지금 연결된 섬에서 아직 연결되지 않은 섬으로 뻗어나갈 수 있는 경로 중 가장 비용이 작은 경로로 집합을 늘려나가면 된다.

이 방법을 사용하면 섬의 추가 순서에 따른 서브트리 문제도 생기지 않는다. 서브트리도 결국 어떤 경로를 통해 메인 트리에 연결될텐데, 이 방법으로는 그 루트부터 집합에 추가되기 때문에 서브트리 자체가 생기지 않는다. 언제나 가능한 경우의 수 중 가장 작은 값으로 섬이 하나씩 추가된다.

물론 이는 간단하지만 n이 작기 때문에 가능한 방법이다. 다른사람들은 크루스칼 혹은 프림 알고리즘을 사용했다고 한다.

---

### 크루스칼 알고리즘 활용

크루스칼 알고리즘은 최소신장트리를 찾는 알고리즘으로 이 문제의 목적과 정확히 일치한다.

과정은 상당히 간단한데, 각 노드의 부모를 저장한 다음, 경로를 오름차순으로 정렬하고 하나씩 연결하는데, 이중 사이클을 만드는 경로 즉 두 노드의 부모 노드가 같은 경우는 연결하지 않는 것이다.

어떤 노드 둘이 연결되면 그 노드의 부모 노드가 작은 쪽이 부모 노드가 되는 식으로 트리가 연결된다. 따라서 어떤 노드들이 연결되면 같은 부모를 갖게 되고, 사이클이 형성되는 것을 피할 수 있다.

### 프림 알고리즘 활용

몰랐는데 내가 처음에 사용한 방법이 프림 알고리즘의 일종이었다. 프림 알고리즘은 임의의 노드를 하나 정해 트리 T에 포함시킨 후, 트리에서 연결되지 않은 다른 정점으로 가는 간선 중 최소값 간선을 선택해 계속해서 노드를 추가하는 방식이다.

이 떄 최소값 간선을 찾는 방법이 배열 혹은 힙을 사용하는 경우가 있는데, 내가 사용한 것은 배열을 사용한 것과 같다. 이떄 복잡도는 O(n^2)이다.

스스로 알고리즘 하나를 생각해내다니 나름 뿌듯한 것 같기도하다.
