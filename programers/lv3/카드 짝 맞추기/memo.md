## [카드 짝 맞추기](https://school.programmers.co.kr/learn/courses/30/lessons/72415)

---

이 문제는 크게 두 가지 부분으로 나누어진다. 하나는 뒤집을 카드의 순서를 정하는 부분과 나머지 하나는 좌표와 좌표 사이의 최소 거리 구해내는 부분이다.

카드는 최대 6종류 있으며 각각 2장씩 존재한다. 이 떄 여러 종류의 카드를 뒤집는 것은 안되므로 한 종류의 카드를 고르면 이 카드의 짝으로 바로 직행해야 한다. 따라서 카드의 종류를 고르는 경우의 수는 6P1이다.

그런데 한 종류의 카드는 2장 존재하고 이중 어느 카드로 먼저 이동할지에 따라서도 결과가 달라진다.
따라서 각 카드를 뽑는 경우의 수에 2가 곱해져 경우의 수는 12 _ 10 _ 8 _ 6 _ 4 \* 2 의 경우의 수를 가진다.

이에 따라 1 ~ 6 까지의 순열을 구하는 함수를 만들어 순열에 따라 카드를 선택하고, 현재 위치와 선택된 카드의 위치를 이용해 최소 이동 거리를 구해내고, 이를 갱신해 나가 비교했을 때 가장 작은 값이 정답이 된다.

순열 하나의 숫자에 어느 카드를 선택하느냐에 따라 2개의 경우의 수가 존재하므로 함수의 구조가 약간 특이해진다. 중요한 점은 카드 쌍 중 어느 카드로 먼저 이동하는지 두 경우의 수를 모두 확인하는 것이다.

```javascript
function combDfs(cy, cx, level, cnt) {
  if (cnt >= answer) return;
  if (level >= 6) {
    answer = Math.min(answer, cnt);
    return;
  }

  for (let i = 1; i <= 6; i++) {
    if (used[i]) continue;

    used[i] = true;
    const cardCouple = cards[i];
    if (cardCouple.length === 0) {
      combDfs(cy, cx, level + 1, cnt);
    } else {
      // 이 부분에서 카드쌍 각각으로 먼저 이동할 경우를 모두 확인해 다음 dfs로 넘긴다.
      const [ey1, ex1] = cardCouple[0];
      const [ey2, ex2] = cardCouple[1];
      const cnt1 =
        getMoveCnt(cy, cx, ey1, ex1) + getMoveCnt(ey1, ex1, ey2, ex2);
      const cnt2 =
        getMoveCnt(cy, cx, ey2, ex2) + getMoveCnt(ey2, ex2, ey1, ex1);
      board[ey1][ex1] = 0;
      board[ey2][ex2] = 0;
      combDfs(ey2, ex2, level + 1, cnt + cnt1);
      combDfs(ey1, ex1, level + 1, cnt + cnt2);
      board[ey1][ex1] = i;
      board[ey2][ex2] = i;
    }
    used[i] = false;
  }
}
```

---

이제 어려운 부분은 최소 거리를 구하는 부분이다. 최소거리 역시 dfs로 구할 수 있지만, 이동 방식에 의해서 조건이 약간 까다로워진다.

커서는 한 칸 이동하거나 벽이나 다른 카드에 부딪힐 때 까지 이동할 수 있다. 특별한 이유가 없다면 가능한 한 카드를 건너뛰어 이동하는것이 더 유리할 것 처럼 보이나, 사실은 그러지 않은 경우가 있다.

    0 0 0 1
    2 0 0 0
    0 1 0 0
    0 0 2 0

위 경우에서 0,3위치에서 2,1 위치로 이동하고자 할 때 왼쪽과 아래 어느 곳으로 건너뛰어 이동하더라도 지나치게 움직이게 되고, 4번 이상의 이동을 하게된다. 최적 이동은 아래로 한 칸 씩 두 번 움직이는 것이다. 그러면 좌측으로 한번에 1까지 도달할 수 있고 총 3번의 이동으로 도달할 수 있게 된다.

따라서 언제나 가장 길게 이동해야 하는 것이 아니므로 이러한 경우를 모두 고려하기 위해선 1칸씩 움직이되, 조건에 따라 이동 횟수를 증가시켜 주는것이 좋다.

그렇다면 이동횟수가 언제 증가하는지 정확히 알 필요가 있다.

1. 방향전환이 일어나면 언제나 이동 횟수가 증가한다.

2. 카드에 도착한 후의 이동은 언제나 이동 횟수가 증가한다.

문제는 같은 방향으로 움직이는 경우이다. 이 경우 벽이나 카드에 부딪히거나 방향 전환이 일어나기 전 까지 이동 횟수가 증가할지 아닐지 아직은 알 수가 없다. 이러한 위치에 도달하기 전 방향 전환이 일어나버린다면 해당 위치까지의 이동횟수가 증가하고, 벽이나 카드에 부딪히면 건너뛰기를 한 것으로 간주되어 이동 횟수가 증가하지 않을 것이다.

따라서 이러한 -직선 이동횟수-를 저장한 tempCnt를 별도로 두고, 같은 방향으로 이동할 때 마다 값을 더해주었다. 이 값은 방향 전환이 일어나면 cnt에 추가되고, 벽이나 카드에 도달하면 0이된다. 이를 이용해 다시 다음과 같이 함수를 만들었다.

1. 정지상태의 방향은 -1이다. 정지상태에서 이동하는 것도 방향 전환으로 간주한다.

2. 방향 전환이 일어나면 이동횟수에 +1 되고 직선 이동횟수 tempCnt가 모두 더해지고 초기화된다.

3. 같은 방향으로 이동하면 직선 이동횟수 tempCnt가 증가한다. 이 때 만약 카드에 도달하거나 벽에 부딪혔다면 tempCnt를 초기화한다.

4. 카드에 도달했다면 정지상태로 간주하고 방향을 -1로 바꾼다.

이 방식을 항상 y1,x1에서 y2,x2까지 도달하는 최소 이동횟수를 구할 수 있다. 직선이동 중 벽에 도달하는지 확인하는 것은 이동방향과 도착지점의 위치를 보면 간단히 알 수 있다.

```javascript
function hasMoveToWall(d, ny, nx) {
  if (d === 0 || d === 1) return ny === 0 || ny === 3;
  else return nx === 0 || nx === 3;
}
```
