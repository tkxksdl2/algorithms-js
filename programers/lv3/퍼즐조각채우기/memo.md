## [퍼즐 조각 채우기](https://school.programmers.co.kr/learn/courses/30/lessons/84021)

---

알고리즘보다 구현 난이도가 어려운 문제. 코드 줄수도 필연적으로 매우 길다.

문제 해결을 위한 단계는 다음과 같다.

1. game_board와 table에서 각각 빈칸, 블럭의 모양 추출

2. 각각의 빈칸에 각각의 블럭 대입 시도

3. 만약 블럭이 맞지 않는다면 회전시켜서 다른 세 방향을 모두 시도.

4. 블럭이 맞으면 블럭과 빈칸을 제외하고, 블럭의 1 개수만큼 answer에 합산.

먼저 블럭과 빈칸의 모양을 추출하는 것은 bfs 함수인 getPiece를 이용했다. getPiece는 type을 두어서 값이 1인 블럭을 찾을 것인지, 0인 빈칸을 찾을 것인지 선택할 수 있다.

이 함수는 bfs로 상하좌우로 이동가능한 칸을 순회하면서, 해당 블럭 혹은 빈칸 모양의 상하좌우 최대 index를 저장한다. 그 index를 이용해서 블럭의 전체 모양과 동일한 직사각형 배열을 만들고 해당 배열에 블럭/빈칸을 복사해 반환한다.

처음에는 효율을 위해 상하좌우 index 만을 리턴했지만, 블럭의 경우 회전을 위해 어차피 배열을 추출할 필요가 있었고, 다음과 같이 특정 블럭이 다른 블럭의 직사각형 위치를 침범하는 경우 문제가 발생했다.

    1 0 1 1 1
    1 0 0 0 1
    1 1 1 0 0

위와 같은 경우 최대 첫 번째 ㄴ자 모양 블럭의 구역에 ㄱ자 모양의 블럭 끄트머리가 걸친다. 때문에 빈 직사각형 배열에 해당되는 블럭 모양만 복사해야 한다.

이렇게 반환된 블럭과 빈칸은 block, blank 배열에 저장되었다. 이제 하나 씩 대입해볼 차례이다.

먼저 블럭과 빈칸을 따로 떼어냈기 때문에 애초에 배열의 y, x 길이가 서로 다른 경우에는 애초에 비교를 하지 않고 넘어간다. 만약 같다면 index를 차례대로 대입해보고, 값이 다른 경우에만 일치하는것으로 본다. 한 구역이라도 값이 같다면 그 블럭은 일치하지 않는다.

하나의 블럭이 일치하지 않는다면 총 세번 더 회전을 시켜본 후에 똑같이 비교해준다. 만약 그 중 한번이라도 모양이 일치한다면 그 블럭과 빈칸은 제외되고, 블럭의 1 개수만큼 answer에 합산한다. 아래는 회전에 사용한 함수 turn이고, 특정 2차원 배열을 시계 반대방향으로 회전하여 반환한다.

```javascript
function turn(piece) {
  let newPiece = new Array(piece[0].length)
    .fill(0)
    .map(() => new Array(piece.length));
  for (let y = 0; y < piece.length; y++) {
    for (let x = 0; x < piece[0].length; x++) {
      newPiece[piece[0].length - 1 - x][y] = piece[y][x];
    }
  }
  return newPiece;
}
```

### 몇몇 케이스를 통과하지 못했던 이유

알고리즘의 흐름 자체는 멀쩡했지만 이상하게 몇몇 케이스에서는 실패가 발생했었다. 자세히 살펴보니 시간이 오래걸리는 케이스 즉 game_board와 table의 크기가 큰 케이스에서 실패가 발생했다. 어디가 문제일까 오래 고민했으나 결과적으로 문제는 getPiece함수의 중복 처리 부분이었다.

이 함수에서 중복 처리를 위해서 y,x index를 y+""+x 로 저장했었는데, 이는 y, x가 한자리수일때는 문제가 없었지만 두 자리수가 넘어가면 11+""+2 와 1+""+12 등 같은 key가 생겨서 문제가 발생했었다. y와 x 사이에 '-'을 넣어주자 해결되었다.
