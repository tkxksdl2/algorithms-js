## [스티커 모으기 2](https://school.programmers.co.kr/learn/courses/30/lessons/12971)

---

처음엔 이 문제를 dp로 풀어야 한다는 생각을 하지 못해서 시간이 꽤 오래걸렸다. 최적화 문제로 풀게되면 경우의 수가 너무 많아져서 문제 정의에 상당히 고전하게된다.

결론적으로 이 문제는 dp로 풀이가 가능하며, dp점화식은 다음과 같다.

    dp[i] = Math.max(dp[i-1], dp[i-2] + sticker[i]);

이 식은 스티커가 인접하여 뜯어질 수 없다는 조건을 나타낸다. 한칸 전 스티커를 뜯었다면 이번 단계의 스티커는 뜯을 수 없기 때문에 두 칸 전의 최대값 + 이번 스티커 값 혹은 한칸 전의 최대값을 그대로 가져오는 것이다.

일반적으로는 이렇게하여 dp 마지막 인덱스를 확인하면 답이 나오겠지만, 리스트가 환형이기 때문에 한 가지의 문제가 더 생긴다.

첫 번째 스티커를 뜯게되면 자연히 마지막 스티커는 뜯을 수 없다. 또한 두 번째 스티커 역시도 뜯을 수 없다. 이 dp에서 초기값은 첫 번째 스티커에서 시작한다. 만약 sticker[0]를 dp[0]으로 하는 하나의 dp만을 확인한다면 두 번째 스티커 혹은 마지막 스티커를 떼는 경우는 절대로 확인할 수 없다.

따라서 dp[0]을 sticker[1]로 하는 dp를 하나 더 진행해야 한다. dps[0]은 sticker의 0에서부터 length-2 까지, dps[1]은 sticker의 1에서부터 length-1 까지의 값을 이용해서 dp를 진행한다. 이 두 가지의 dp를 모두 진행한 후 둘의 끝값 중 더 큰 값이 정답이 된다.
