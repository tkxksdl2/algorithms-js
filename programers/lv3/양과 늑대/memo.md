## [2022 카카오 양과 늑대](https://school.programmers.co.kr/learn/courses/30/lessons/92343)

---

약간의 조건이 추가된 그래프 문제. 보통 그래프 문제는 dfs 혹은 bfs로 풀이하는데, 이 문제의 경우에는 일반적인 dfs 혹은 bfs만으로는 조건을 완벽히 풀이하지 못한다.

먼저 이 문제에서 경로 선택에 대해 정의할 필요가 있다. 루트 노드는 항상 0이고, 0인 노드는 양이 존재하므로 항상 비용없이 통과할 수 있다. 따라서 열린 경로 내에서 항상 모을 수 있는 최대 양 수를 구할수 있다.

1인 노드는 늑대가 존재하는 노드로 이 노드를 선택하려면 1의 비용을 지불해야 한다. 이 비용의 누적이 현재 모은 양의 개수와 같아진다면 해당 노드는 선택할 수 없다. 즉 이 문제에서 특정 경로를 선택한다는 것은 가능한 자식 노드 중 늑대가 있는 노드를 선택해 비용을 지불하고 열린 경로로 만든다는 의미이다.

이 문제를 일반적인 dfs처럼 자식 노드를 열거하고 순서대로 방문하는 방식으로 풀 수 없는 이유는 자식 노드를 방문하는 순서가 결과에 영향을 끼치기 때문이다. 특정 위치의 늑대 노드를 먼저 연다면 많은 양을 수집해 이전에는 열 수 없었던 늑대 노드를 열 가능성이 생기게 된다.

또한 늑대 노드를 여는 것은 마지막에 연 노드의 깊이나 위치에 전혀 영향을 받지 않는다. 현재 열린 경로 상에서 접촉 가능한 모든 늑대 노드들은 항상 검사 가능한 상태이며 이에 따른 비용이나 특별한 제한도 존재하지 않는다.

때문에 dfs의 각 단계는 트리의 특정 레벨에 의존해서는 안된다. dfs의 매 단계에는 현재 열린 경로에서 접촉 가능한 모든 늑대 노드를 검사해야 한다. 이러한 동작은 bfs로 쉽게 구현할 수 있다.

따라서 나는 전체적으로는 dfs를 쓰고, dfs 함수 내에서 bfs를 사용해 접촉 가능한 모든 늑대 노드를 찾았다. bfs는 항상 루프 노드에서부터 시작하여 열린 노드를 순회하고, 양 노드일 경우 점수를 올리고 늑대 노드일 경우 dfs의 다음 단계를 위한 nxtWolves 리스트에 넣어주었다.

nxtWolves는 현재 단계에서 접촉 가능한 모든 늑대 노드의 리스트이다. 이 늑대 노드들을 하나 씩 열린 노드로 바꿔준 후 다음 dfs를 호출했다. 이때 이 늑대 노드 값은 일시적으로 2가 되는데, 이는 열린 노드이면서도 양 개수를 늘리지 않는 노드라는 의미이다. dfs는 현재 단계에서 늑대 노드를 열기 위해 사용한 총 비용을 인자로 받으므로 특정 경로에서 더이상 늑대 노드를 열 수 없을 때 dfs를 끊어줄 수 있다.

일반적으로 이렇게 매 단계에서 가능한 모든 노드를 순회하는 것은 부하가 심할 테지만 이 문제에서는 정확성 테스트 외에 특별한 제한이 존재하지 않고, 노드 수도 최대 17개이므로 무리 없이 문제를 해결할 수 있다.
