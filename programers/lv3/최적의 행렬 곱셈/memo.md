## [최적의 행렬 곱셈](https://school.programmers.co.kr/learn/courses/30/lessons/12942)

---

문제를 풀기에 앞서서, 이 문제엔 matrix_sizes는 행렬 곱셈이 가능한 형태로 이미 정렬되어 있으며, 그 자체로 하나의 행렬곱을 나타낸다는 꼭 필요한 설명이 빠져있다. 아무래도 옛날 문제이다 보니 관리가 잘 되지 않는 듯 하다. 자세한 설명은 내가 [programers](https://school.programmers.co.kr/questions/54538) 에 작성해놓았다.

처음에 이 문제를 최적화 방식으로 문제에 접근했었다. (l,m) \* (m,r) 행렬곱이 일어날 때 마다 l \* m \* r 의 값이 더해지며 m에 해당하는 숫자는 지워져 앞으로 사용되지 않는다. 그렇다면 가능한 큰 m을 먼저 지워가며 행렬곱을 하면 최적화가 일어나지 않을까?

하지만 가장 큰 m을 지운다고 해도 이 때 양 옆 l, k의 값이 같이 곱해지기 때문에 항상 최선이라는 보장이 없다. 당연히 대부분의 테스트케이스를 통과하지 못했고, 결국엔 모든 케이스를 확인해야 한다는 결론이 내려졌다.

---

하지만 행렬의 개수가 최대 200개이므로 모든 순서를 일일히 dfs로 확인하다간 시간초과가 뻔하므로, 이전 단계를 저장하는 dp 방식을 사용해볼 수 있다. 이 때 dp를 정의하기 위해 행렬의 곱셈이 일어나는 방식을 자세히 살펴 볼 필요가 있다.

    A * B * C * D
    (A * B) * C * D
    ((A * B) * C) * D
    (((A * B) * C) * D)

이는 앞에서부터 순차적으로 행렬곱을 해나간 결과이다. 여기서 알 수 있듯이 특정 단계의 행렬곱은 이전 단계의 행렬곱의 곱으로 표현할 수 있다. 그렇다면 dp를 이용해 이전 단계의 행렬곱 결과를 기억한다면 다음 단계의 행렬곱에 사용할 수 있다는 의미가 된다.

그렇다면 dp의 한 축은 행렬곱의 단계:행렬곱에 사용된 행렬 수로 정의할 수 있다. 나머지 한 축은 행렬곱의 시작 index로 정의한다. 행렬곱에 사용된 행렬 수가 늘어나니 사용 가능한 시작 index는 점점 줄어갈 것이다. 따라서 dp는 자연스레 역삼각형 모양을 띄게 될 것이다.

따라서 dp[tSize][i] 는 i번째 행렬부터 tSize개 만큼의 행렬의 곱했을 때의 곱셈 횟수 중 최솟값을 의미한다. 이 때 최솟값은 tSize, i에 해당하는 행렬곱을 만들기 위한 이전 단계의 최솟값들과 현재 단계에 더해질 곱셈 결과의 합으로 구할 수 있다.

예를 들어 다음과 같은 행렬이 존재한다면, 최소값 갱신은 다음과 같이 이루어진다.

    [[4, 5], [5, 3], [3, 3], [3, 3], [3, 4]]

    1: 0,  0,  0,  0,  0
    2: 60, 45, 27, 36

tSize가 1 이면 곱셈 횟수는 0이다. 스스로 곱셈할 수는 없기 때문이다. 2 일때는 우측으로 인접한 행렬과의 행렬곱 횟수이다.

tSize가 3부터는 본격적으로 이전 단계를 참조하기 시작한다. 예를 들어 tSize=3, i=0 이라면 다음과 같은 행렬들의 곱 최소값을 나타낸다.

    [4, 5], [5, 3], [3, 3]

이는 다음과 같이 분할될 수 있다.

    ([4, 5], [5, 3]), [3, 3] or [4, 5], ([5, 3], [3, 3])

이 값들은 각각 dp[2][0] + dp[1][2] 그리고 dp[1][0] + dp[2][1]을 나타낸다. 여기에 이번에 더해지는 값은 이 분할된 행렬 중 (좌측 행렬의 첫값) * (좌측 행렬의 끝값 *혹은 우측 행렬의 첫값*) * (우측 행렬의 끝값) 이 된다.

matrix_size를 m이라고 한다면 더해지는 값은 각각 m[0][0] \* m[1][1] \* m[2][1] 그리고 m[0][0] \* m[2][1] \* m[2][1] 이 된다. 행렬을 어떻게 분할하는지에 따라 이전 값이 모두 달라지고, 이번에 더해지는 곱셈식의 중간 값이 달라지는 것을 알 수 있다. 따라서 행렬을 분할하는 방법에 대한 변수와 순회가 추가로 필요하다.

그렇다면 dp 순회는 tSize에 대한 순회 -> 시작 index i에 대한 순회 -> 행렬[i:i+tSizs] 까지를 어떻게 분할하느냐에 대한 순회로 이어진다. 이 마지막 순회를 행렬곱 중 왼쪽 행렬의 행렬의 행렬곱 횟수 lSize로 나타낸다면, dp 갱신은 아래와 같이 정의된다.

```javascript
for (let tSize = 2; tSize <= matrix_sizes.length; tSize++) {
  for (let i = 0; i <= matrix_sizes.length - tSize; i++) {
    for (let lSize = 1; lSize < tSize; lSize++) {
      dp[tSize][i] = Math.min(
        dp[tSize][i],
        dp[lSize][i] +
          dp[tSize - lSize][i + lSize] +
          matrix_sizes[i][0] *
            matrix_sizes[i + lSize - 1][1] *
            matrix_sizes[i + tSize - 1][1]
      );
    }
  }
}
```

모든 dp 순회가 끝나면 dp는 아래와 같은 모습이 된다.

    [ Infinity, Infinity, Infinity, Infinity, Infinity ],
    [ 0, 0, 0, 0, 0 ],
    [ 60, 45, 27, 36, Infinity ],
    [ 96, 72, 63, Infinity, Infinity ],
    [ 123, 123, Infinity, Infinity, Infinity ],
    [ 171, Infinity, Infinity, Infinity, Infinity ]

이 중 전체 행렬의 행렬곱을 나타내는 dp[matrix_sizes.length][0]이 정답이 된다.
