## [단체사진 찍기](https://school.programmers.co.kr/learn/courses/30/lessons/1835)

---

dfs를 이용한 순열을 만들면서, 동시에 복잡한 조건을 검증하는 문제이다.

먼저 각 알파벳을 index로 활용하고자 하므로 알파벳에 각각 숫자를 할당한다.

dfs를 이용해 일반적인 순열을 만드는 함수를 작성했다. 하지만 각 숫자를 순열의 위치에 할당하기 전에 문제에서 제시한 조건을 검증하는 동작이 필요하다.

이를 위해 제시되는 조건을 파싱하는것이 선행되었다. 각 조건은 두 알파벳 사이의 거리를 제한하는 방식으로 작성된다. 따라서 조건이 하나 지정될 때 마다 특정 두 알파벳 사이의 거리에 제한이 생긴다.

이 때 조건이 "A~C>2"라면 A 와 C 사이엔 2개 이상의 알파벳이 존재해야 한다는 의미이고, 거리상으로는 3칸 이상 차이나야 한다는 의미이다.

알파벳은 총 8개이기 때문에 알파벳과 알파벳 사이의 거리는 0~7까지 존재한다. 따라서 알파벳과 알파벳 사이에 대해 어떤 특정 거리의 배치가 가능한지 저장하는 3차원 boolean 배열 condition을 만들었다. 예를 들어 A=0 과 C=1이 3인 거리에 배치될 수 있는지를 알려주는 데이터는 condition[0][1][3]이다.

따라서 조건의 배열인 data를 순회하며 각 조건에 맞게 condition을 변화한다.
앞선 조건 "A~C>2"를 파싱한다면 condition[0][1] 그리고 condtion[1][0]은 다음과 같은 모습일 것이다.

    [false, false, false, true, true, true, true, true]

만약 조건을 파싱했을 때 해당 condition 라인이 전부 false라면 주어진 조건 하에 해당 알파벳 둘을 배치할 수 있는 방법이 없다는 의미이다. 따라서 0을 리턴한다.

위와같은 condition 배열이 완성되면 이미 배치된 알파벳들과 비교해 한 번의 참조만으로 해당 알파벳이 순열의 해당 순서에 배치될 수 있는지 확인할 수 있다. 이 조건을 dfs에 추가해주기만 하면 답을 얻을 수 있다.

---

다른 사람의 코드를 보니 완성된 순열에서 조건을 검증하는것을 확인했는데, 해당 방법보다 내 코드가 훨씬 속도와 메모리를 덜 차지했다.

순열을 배치하는 중간에 조건을 위배한다면, 그 순열은 더이상 진행할 필요가 없다. 따라서 완성된 순열에서 조건을 검증하는 것은 가지치기가 일어나지 않으므로 순열의 모든 경우의 수 8!을 검증한다. 따라서 순열의 중간에 조건을 확인하는 것이 속도 면에서 훨씬 유리하다는 것을 알 수 있다.
