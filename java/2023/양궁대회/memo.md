## [kakao 2022](https://school.programmers.co.kr/learn/courses/30/lessons/92342)

---

dfs를 이용해 조합을 만들어내는 문제. 카카오답게 여러 세부조건이 많아 구현이 복잡해진다.

특정 점수를 따내려면 어피치가 그 곳에 쏜 화살보다 1개 많게 화살을 쏘아야만 한다. 그보다 많게 쏘는 경우는 점수에 변화가 없으므로 아무 의미가 없다. 따라서 각 점수에 대해서 점수를 차지하기 위한 화살 비용을 정의할 수 있고, 그 비용을 costs라고 한다.

이것으로 어떤 점수 구역을 차지하고 차지하지 않을 것인지에 대해 조합을 만들 수 있다. 그러나 이 조합이 일반적인 조합과 다른 점은 몇 개의 구역을 차지할지를 미리 알 수 없다는 점이다.

다음으로 dfs 함수 getComb를 통해 조합을 구한다. 10점부터 시작하여 현재 구역에 관한 비용을 지불하고 점수를 따낼 수 있는 경우에 그 구역을 따내고 다음 단계로 진입한다. 이때 점수차를 갱신하는데, 최초값은 -어피치의 점수 이며, 해당 구역에 어피치가 화살을 쏜 경우 어피치의 득점도 무효화되므로 점수의 2배만큼 더한다. 아니라면 점수만큼만 더한다.

일반적인 조합을 구하는 방법과 같이 다음 단계는 현재 index +1부터 끝까지 시작한다. 그러나 몇 개의 구역을 차지할지 미리 알 수 없으므로, 일단 깊이가 깊어져 순회가 시작되면 끝 인덱스까지는 확인해야만 한다.

다음 단계에 진입했을 때, 점수차 값이 현재 저장된 max 총합값 보다 크다면 답을 갱신한다. 값이 같다면 문제에서 제시한 조건과 같이, 뒤 인덱스부터 조회하여 가장 작은 점수의 화살 개수가 큰 경우에 값을 갱신한다.

이 때 만약 화살을 다 사용하지 않았다면 남은 화살을 모두 0점에 넣어주어야 한다. 사실 n이 남아 0점에 들어가는것이 정답이 되는 경우는 이미 가능한 모든 구역을 전부 점령했을 때 밖에 없으므로, 작은 점수의 최대화살개수 조건을 만족하기 위해서는 되도록 0점의 값이 커야만 한다.
