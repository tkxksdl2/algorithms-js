## [줄 서는 방법](https://school.programmers.co.kr/learn/courses/30/lessons/12936)

---

기본적으로 순열을 구하는 문제이지만, 효율성 테스트 조건이 타이트해서 최적화를 잘 해야하는 문제이다.

먼저 순열을 오름차순으로 구하기 위해서 1 부터 n 까지의 숫자를 순서대로 각 자릿수에 대입한다. n이 5라면 첫 순열은 [1, 2, 3, 3, 5] 가 되고, 마지막 순열은 [5, 4, 3, 2, 1]이 될 것이다.

이는 다음 자릿수에도 동일하게 수행되며, 이미 대입한 숫자는 used boolean 배열을 통해서 구분한다.

여기까지는 일반적인 순열 구하기와 같지만, 구해야 할 것은 k 번 째 순열 단 하나 뿐이다. 그리고 k의 크기가 최대 20!으로 매우 클 수 있기 때문에, 오름차순으로 숫자를 대입하는것은 맞지만 적절하게 스킵하는것이 중요하다.

---

스킵은 다음과 같이 일어난다. n이 5 이고 k가 100 이라고 가정한다.

맨 처음 자릿수를 정할 때, 오름차순이므로 1부터 대입될 것이다.

    1 _ _ _ _

그러면 남은 자릿수는 4 자리이고, 남은 숫자도 4 개이므로 이 4 개의 숫자를 순서가 있는 순열로 나타내는 방법은 4! = 4 _ 3 _ 2 \* 1 = 24가지 이다.

그 말인 즉 첫 번째 자릿수가 1인 순열의 개수는 24개이다. 구해야 할 k는 100 이므로, 첫 자릿수가 1인 모든 순열 24가지는 고려하지 않고 다음 숫자로 넘어갈 수 있다.

이러한 방법을 반복하면 첫 번째 자릿수는 5까지 스킵이 가능하다. 하나의 숫자가 넘어갈 때 마다 k가 24 씩 증가하므로, 첫 번째 자릿수가 5까지 증가하면 k는 96이 된다. 그 다음으론 더이상 스킵할 수 없으므로 첫 자릿수는 5로 확정된다.

이제 다음 자릿수부터 같은 작업을 반복하면 된다. 사용되지 않은 숫자 중 가장 작은 숫자는 1이다.

    5 1 _ _ _

이 떄 남은 세 자리를 이용한 순열은 3! = 6 가지가 있으며, 두 번째 자리의 숫자가 증가할 때 마다 k는 6이 늘어난다. 현재 k 는 96이므로 6을 늘릴 수 없다. 따라서 1이 확정된다.

    5 1 ? _ _

다음은 세 번째 자릿수를 정하며, 사용 가능한 가장 작은 숫자는 2 이다. 이 때 나머지 2 자릿수를 이용한 순열은 2! = 2 가지이며, 현재 k가 96 이므로 4가 남는다.

이 때 스킵은 k보다 작은 경우에만 가능한데, 스킵은 그 순번까지를 검사하지 않는다는 의미이므로 마지막 숫자를 확정할 k가 1 필요하기 때문이다.

따라서 한 번 스킵할 수 있고 세 번째 자리 숫자는 2 -> 3 이 된다.

    5 1 3 ? _

이제 k는 96 + 2 = 98이 되었다. 마지막 한 자리 숫자의 순열 개수는 1 이므로 한 번 스킵이 가능하다.따라서 네 번째 자릿수의 숫자는 2 -> 4 가 되며, k는 99이다.

    5 1 3 4 2

마지막 자릿수에 남은 숫자 2를 넣음으로써 k +1이 되고, k가 100이 되었으므로 답이 완성된다.
